"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "(pages-dir-browser)/../node_modules/next/dist/client/index.js":
/*!*************************************************!*\
  !*** ../node_modules/next/dist/client/index.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(pages-dir-browser)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n/* global location */ // imports polyfill from `@next/polyfill-module` after build.\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    emitter: function() {\n        return emitter;\n    },\n    hydrate: function() {\n        return hydrate;\n    },\n    initialize: function() {\n        return initialize;\n    },\n    router: function() {\n        return router;\n    },\n    version: function() {\n        return version;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(pages-dir-browser)/../node_modules/react/jsx-runtime.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"(pages-dir-browser)/../node_modules/next/dist/build/polyfills/polyfill-module.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(pages-dir-browser)/../node_modules/react/index.js\"));\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"(pages-dir-browser)/../node_modules/react-dom/client.js\"));\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/mitt */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/mitt.js\"));\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _disablesmoothscroll = __webpack_require__(/*! ../shared/lib/router/utils/disable-smooth-scroll */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js\");\nconst _isdynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/utils.js\");\nconst _portal = __webpack_require__(/*! ./portal */ \"(pages-dir-browser)/../node_modules/next/dist/client/portal/index.js\");\nconst _headmanager = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./head-manager */ \"(pages-dir-browser)/../node_modules/next/dist/client/head-manager.js\"));\nconst _pageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./page-loader */ \"(pages-dir-browser)/../node_modules/next/dist/client/page-loader.js\"));\nconst _routeannouncer = __webpack_require__(/*! ./route-announcer */ \"(pages-dir-browser)/../node_modules/next/dist/client/route-announcer.js\");\nconst _router = __webpack_require__(/*! ./router */ \"(pages-dir-browser)/../node_modules/next/dist/client/router.js\");\nconst _iserror = __webpack_require__(/*! ../lib/is-error */ \"(pages-dir-browser)/../node_modules/next/dist/lib/is-error.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _removebasepath = __webpack_require__(/*! ./remove-base-path */ \"(pages-dir-browser)/../node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ./has-base-path */ \"(pages-dir-browser)/../node_modules/next/dist/client/has-base-path.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _adapters = __webpack_require__(/*! ../shared/lib/router/adapters */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/adapters.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../shared/lib/hooks-client-context.shared-runtime */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _onrecoverableerror = __webpack_require__(/*! ./react-client-callbacks/on-recoverable-error */ \"(pages-dir-browser)/../node_modules/next/dist/client/react-client-callbacks/on-recoverable-error.js\");\nconst _tracer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/tracer */ \"(pages-dir-browser)/../node_modules/next/dist/client/tracing/tracer.js\"));\nconst _isnextroutererror = __webpack_require__(/*! ./components/is-next-router-error */ \"(pages-dir-browser)/../node_modules/next/dist/client/components/is-next-router-error.js\");\nconst version = \"16.1.1\";\nlet router;\nconst emitter = (0, _mitt.default)();\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet devClient;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nclass Container extends _react.default.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && (initialData.isFallback || initialData.nextExport && ((0, _isdynamic.isDynamicRoute)(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + '?' + String((0, _querystring.assign)((0, _querystring.urlQueryToSearchParams)(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (false) {} else {\n            const { PagesDevOverlayBridge } = __webpack_require__(/*! ../next-devtools/userspace/pages/pages-dev-overlay-setup */ \"(pages-dir-browser)/../node_modules/next/dist/next-devtools/userspace/pages/pages-dev-overlay-setup.js\");\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(PagesDevOverlayBridge, {\n                children: this.props.children\n            });\n        }\n    }\n}\nasync function initialize(opts = {}) {\n    // This makes sure this specific lines are removed in production\n    if (true) {\n        _tracer.default.onSpanEnd((__webpack_require__(/*! ./tracing/report-to-socket */ \"(pages-dir-browser)/../node_modules/next/dist/client/tracing/report-to-socket.js\")[\"default\"]));\n        devClient = opts.devClient;\n    }\n    initialData = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\n    window.__NEXT_DATA__ = initialData;\n    defaultLocale = initialData.defaultLocale;\n    const prefix = initialData.assetPrefix || '';\n    self.__next_set_public_path__(`${prefix}/_next/`);\n    asPath = (0, _utils.getURL)();\n    // make sure not to attempt stripping basePath for 404s\n    if ((0, _hasbasepath.hasBasePath)(asPath)) {\n        asPath = (0, _removebasepath.removeBasePath)(asPath);\n    }\n    if (false) {}\n    if (initialData.scriptLoader) {\n        const { initScriptLoader } = __webpack_require__(/*! ./script */ \"(pages-dir-browser)/../node_modules/next/dist/client/script.js\");\n        initScriptLoader(initialData.scriptLoader);\n    }\n    pageLoader = new _pageloader.default(initialData.buildId, prefix);\n    const register = ([r, f])=>pageLoader.routeLoader.onEntrypoint(r, f);\n    if (window.__NEXT_P) {\n        // Defer page registration for another tick. This will increase the overall\n        // latency in hydrating the page, but reduce the total blocking time.\n        window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n    }\n    window.__NEXT_P = [];\n    window.__NEXT_P.push = register;\n    headManager = (0, _headmanager.default)();\n    headManager.getIsSsr = ()=>{\n        return router.isSsr;\n    };\n    appElement = document.getElementById('__next');\n    return {\n        assetPrefix: prefix\n    };\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(App, {\n        ...appProps\n    });\n}\nfunction AppContainer({ children }) {\n    _s();\n    // Create a memoized value for next/navigation router context.\n    const adaptedForAppRouter = _react.default.useMemo({\n        \"AppContainer.useMemo[adaptedForAppRouter]\": ()=>{\n            return (0, _adapters.adaptForAppRouterInstance)(router);\n        }\n    }[\"AppContainer.useMemo[adaptedForAppRouter]\"], []);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(Container, {\n        fn: (error)=>renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error('Error rendering page: ', err)),\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n            value: adaptedForAppRouter,\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                value: (0, _adapters.adaptForSearchParams)(router),\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_adapters.PathnameContextProviderAdapter, {\n                    router: router,\n                    isAutoExport: self.__NEXT_DATA__.autoExport ?? false,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                        value: (0, _adapters.adaptForPathParams)(router),\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_routercontextsharedruntime.RouterContext.Provider, {\n                            value: (0, _router.makePublicRouterInstance)(router),\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n                                value: headManager,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_imageconfigcontextsharedruntime.ImageConfigContext.Provider, {\n                                    value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[32,48,64,96,128,256,384],\"qualities\":[75,70,70,70,70,70,70,70,70,70,70,70,70,70],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[{\"protocol\":\"https\",\"hostname\":\"image.tmdb.org\",\"pathname\":\"/t/p/**\"},{\"protocol\":\"http\",\"hostname\":\"localhost\",\"port\":\"5050\",\"pathname\":\"/uploads/**\"},{\"protocol\":\"http\",\"hostname\":\"127.0.0.1\",\"port\":\"5050\",\"pathname\":\"/uploads/**\"}],\"localPatterns\":[{\"pathname\":\"**\",\"search\":\"\"}]},\n                                    children: children\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n}\n_s(AppContainer, \"F6BSfrFQNeqenuPnUMVY/6gI8uE=\");\n_c = AppContainer;\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = {\n            ...wrappedAppProps,\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        };\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(AppContainer, {\n            children: renderApp(App, appProps)\n        });\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App, err } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        devClient.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(`A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred`);\n    return pageLoader.loadPage('/_error').then(({ page: ErrorComponent, styleSheets })=>{\n        return lastAppProps?.Component === ErrorComponent ? Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_error */ \"(pages-dir-browser)/../node_modules/next/dist/pages/_error.js\"))).then((errorModule)=>{\n            return Promise.resolve().then(()=>/*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../pages/_app */ \"(pages-dir-browser)/../node_modules/next/dist/pages/_app.js\"))).then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then(({ ErrorComponent, styleSheets })=>{\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(renderErrorProps.props?.err ? renderErrorProps.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then((initProps)=>doRender({\n                ...renderErrorProps,\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            }));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head({ callback }) {\n    _s1();\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect({\n        \"Head.useLayoutEffect\": ()=>callback()\n    }[\"Head.useLayoutEffect\"], [\n        callback\n    ]);\n    return null;\n}\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nconst performanceMarks = {\n    navigationStart: 'navigationStart',\n    beforeRender: 'beforeRender',\n    afterRender: 'afterRender',\n    afterHydrate: 'afterHydrate',\n    routeChange: 'routeChange'\n};\nconst performanceMeasures = {\n    hydration: 'Next.js-hydration',\n    beforeHydration: 'Next.js-before-hydration',\n    routeChangeToRender: 'Next.js-route-change-to-render',\n    render: 'Next.js-render'\n};\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    ;\n    [\n        performanceMarks.beforeRender,\n        performanceMarks.afterHydrate,\n        performanceMarks.afterRender,\n        performanceMarks.routeChange\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterHydrate) // mark end of hydration\n    ;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, 'mark').length;\n    if (hasBeforeRenderMark) {\n        const beforeHydrationMeasure = performance.measure(performanceMeasures.beforeHydration, performanceMarks.navigationStart, performanceMarks.beforeRender);\n        const hydrationMeasure = performance.measure(performanceMeasures.hydration, performanceMarks.beforeRender, performanceMarks.afterHydrate);\n        if ( true && // Old versions of Safari don't return `PerformanceMeasure`s from `performance.measure()`\n        beforeHydrationMeasure && hydrationMeasure) {\n            _tracer.default.startSpan('navigation-to-hydration', {\n                startTime: performance.timeOrigin + beforeHydrationMeasure.startTime,\n                attributes: {\n                    pathname: location.pathname,\n                    query: location.search\n                }\n            }).end(performance.timeOrigin + hydrationMeasure.startTime + hydrationMeasure.duration);\n        }\n    }\n    if (onPerfEntry) {\n        performance.getEntriesByName(performanceMeasures.hydration).forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterRender) // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(performanceMarks.routeChange, 'mark');\n    if (!navStartEntries.length) return;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, 'mark').length;\n    if (hasBeforeRenderMark) {\n        performance.measure(performanceMeasures.routeChangeToRender, navStartEntries[0].name, performanceMarks.beforeRender);\n        performance.measure(performanceMeasures.render, performanceMarks.beforeRender, performanceMarks.afterRender);\n        if (onPerfEntry) {\n            performance.getEntriesByName(performanceMeasures.render).forEach(onPerfEntry);\n            performance.getEntriesByName(performanceMeasures.routeChangeToRender).forEach(onPerfEntry);\n        }\n    }\n    clearMarks();\n    [\n        performanceMeasures.routeChangeToRender,\n        performanceMeasures.render\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(performanceMarks.beforeRender);\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = _client.default.hydrateRoot(domEl, reactEl, {\n            onRecoverableError: _onrecoverableerror.onRecoverableError\n        });\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = _react.default.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root({ callbacks, children }) {\n    _s2();\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect({\n        \"Root.useLayoutEffect\": ()=>callbacks.forEach({\n                \"Root.useLayoutEffect\": (callback)=>callback()\n            }[\"Root.useLayoutEffect\"])\n    }[\"Root.useLayoutEffect\"], [\n        callbacks\n    ]);\n    if (false) {}\n    return children;\n}\n_s2(Root, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c2 = Root;\nfunction doRender(input) {\n    let { App, Component, props, err } = input;\n    let styleSheets = 'initial' in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = {\n        ...props,\n        Component,\n        err,\n        router\n    };\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = Object.defineProperty(new Error('Cancel rendering route'), \"__NEXT_ERROR_CODE\", {\n                value: \"E503\",\n                enumerable: false,\n                configurable: true\n            });\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== 'production') {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute('data-n-href')));\n        const noscript = document.querySelector('noscript[data-n-css]');\n        const nonce = noscript?.getAttribute('data-n-css');\n        styleSheets.forEach(({ href, text })=>{\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement('style');\n                styleTag.setAttribute('data-n-href', href);\n                styleTag.setAttribute('media', 'x');\n                if (nonce) {\n                    styleTag.setAttribute('nonce', nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (false) {}\n        if (input.scroll) {\n            const { x, y } = input.scroll;\n            (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=>{\n                window.scrollTo(x, y);\n            });\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n                callback: onHeadCommit\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)(AppContainer, {\n                children: [\n                    renderApp(App, appProps),\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_portal.Portal, {\n                        type: \"next-route-announcer\",\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_routeannouncer.RouteAnnouncer, {})\n                    })\n                ]\n            })\n        ]\n    });\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ],\n            children:  false ? /*#__PURE__*/ 0 : elem\n        }));\n    return renderPromise;\n}\nasync function render(renderingProps) {\n    // if an error occurs in a server-side page (e.g. in getInitialProps),\n    // skip re-rendering the error page client-side as data-fetching operations\n    // will already have been done on the server and NEXT_DATA contains the correct\n    // data for straight-forward hydration of the error page\n    if (renderingProps.err && // renderingProps.Component might be undefined if there is a top/module-level error\n    (typeof renderingProps.Component === 'undefined' || !renderingProps.isHydratePass)) {\n        await renderError(renderingProps);\n        return;\n    }\n    try {\n        await doRender(renderingProps);\n    } catch (err) {\n        const renderErr = (0, _iserror.getProperError)(err);\n        // bubble up cancelation errors\n        if (renderErr.cancelled) {\n            throw renderErr;\n        }\n        if (true) {\n            // Ensure this error is displayed in the overlay in development\n            setTimeout(()=>{\n                throw renderErr;\n            });\n        }\n        await renderError({\n            ...renderingProps,\n            err: renderErr\n        });\n    }\n}\nasync function hydrate(opts) {\n    let initialErr = initialData.err;\n    try {\n        const appEntrypoint = await pageLoader.routeLoader.whenEntrypoint('/_app');\n        if ('error' in appEntrypoint) {\n            throw appEntrypoint.error;\n        }\n        const { component: app, exports: mod } = appEntrypoint;\n        CachedApp = app;\n        if (mod && mod.reportWebVitals) {\n            onPerfEntry = ({ id, name, startTime, value, duration, entryType, entries, attribution })=>{\n                // Combines timestamp with random number for unique ID\n                const uniqueID = `${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`;\n                let perfStartEntry;\n                if (entries && entries.length) {\n                    perfStartEntry = entries[0].startTime;\n                }\n                const webVitals = {\n                    id: id || uniqueID,\n                    name,\n                    startTime: startTime || perfStartEntry,\n                    value: value == null ? duration : value,\n                    label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'\n                };\n                if (attribution) {\n                    webVitals.attribution = attribution;\n                }\n                mod.reportWebVitals(webVitals);\n            };\n        }\n        const pageEntrypoint = // error, so we need to skip waiting for the entrypoint.\n         true && initialData.err ? {\n            error: initialData.err\n        } : await pageLoader.routeLoader.whenEntrypoint(initialData.page);\n        if ('error' in pageEntrypoint) {\n            throw pageEntrypoint.error;\n        }\n        CachedComponent = pageEntrypoint.component;\n        if (true) {\n            const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"(pages-dir-browser)/../node_modules/next/dist/compiled/react-is/index.js\");\n            if (!isValidElementType(CachedComponent)) {\n                throw Object.defineProperty(new Error(`The default export is not a React Component in page: \"${initialData.page}\"`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E286\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n        }\n    } catch (error) {\n        // This catches errors like throwing in the top level of a module\n        initialErr = (0, _iserror.getProperError)(error);\n    }\n    if (true) {\n        const getServerError = (__webpack_require__(/*! ../server/dev/node-stack-frames */ \"(pages-dir-browser)/../node_modules/next/dist/server/dev/node-stack-frames.js\").getServerError);\n        // Server-side runtime errors need to be re-thrown on the client-side so\n        // that the overlay is rendered.\n        if (initialErr) {\n            if (initialErr === initialData.err) {\n                setTimeout(()=>{\n                    let error;\n                    try {\n                        // Generate a new error object. We `throw` it because some browsers\n                        // will set the `stack` when thrown, and we want to ensure ours is\n                        // not overridden when we re-throw it below.\n                        throw Object.defineProperty(new Error(initialErr.message), \"__NEXT_ERROR_CODE\", {\n                            value: \"E394\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    } catch (e) {\n                        error = e;\n                    }\n                    error.name = initialErr.name;\n                    error.stack = initialErr.stack;\n                    const errSource = initialErr.source;\n                    // In development, error the navigation API usage in runtime,\n                    // since it's not allowed to be used in pages router as it doesn't contain error boundary like app router.\n                    if ((0, _isnextroutererror.isNextRouterError)(initialErr)) {\n                        error.message = 'Next.js navigation API is not allowed to be used in Pages Router.';\n                    }\n                    throw getServerError(error, errSource);\n                });\n            } else {\n                setTimeout(()=>{\n                    throw initialErr;\n                });\n            }\n        }\n    }\n    if (window.__NEXT_PRELOADREADY) {\n        await window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n    }\n    router = (0, _router.createRouter)(initialData.page, initialData.query, asPath, {\n        initialProps: initialData.props,\n        pageLoader,\n        App: CachedApp,\n        Component: CachedComponent,\n        wrapApp,\n        err: initialErr,\n        isFallback: Boolean(initialData.isFallback),\n        subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                App,\n                scroll\n            })),\n        locale: initialData.locale,\n        locales: initialData.locales,\n        defaultLocale,\n        domainLocales: initialData.domainLocales,\n        isPreview: initialData.isPreview\n    });\n    initialMatchesMiddleware = await router._initialMatchesMiddlewarePromise;\n    const renderCtx = {\n        App: CachedApp,\n        initial: true,\n        Component: CachedComponent,\n        props: initialData.props,\n        err: initialErr,\n        isHydratePass: true\n    };\n    if (opts?.beforeRender) {\n        await opts.beforeRender();\n    }\n    render(renderCtx);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxtQkFBbUIsR0FDbkIsNkRBQTZEOzs7Ozs7Ozs7Ozs7O0lBeUVoREEsT0FBTztlQUFQQTs7SUFxdkJTQyxPQUFPO2VBQVBBOztJQWxvQkFDLFVBQVU7ZUFBVkE7O0lBcEhYQyxNQUFNO2VBQU5BOztJQURFQyxPQUFPO2VBQVBBOzs7OztvQkF0RU47NEVBUXlCOzZFQUNYOzZEQUNjOzJFQUNsQjt3REFFYTtpREFDMkI7dUNBQzFCO3lDQUl4QjttQ0FDeUM7b0NBRXpCO2tGQUNLO2lGQUNMOzRDQUVRO29DQUN3QjtxQ0FDeEI7NkRBQ0k7NENBRUo7eUNBQ0g7MkRBQ0s7c0NBTTFCOzZEQUlBO2dEQUM0Qjs2RUFDaEI7K0NBQ2U7QUF3QjNCLE1BQU1BLFVBQVVDLFFBQVFDO0FBQ3hCLElBQUlIO0FBQ0osTUFBTUgsVUFBK0JRLENBQUFBLEdBQUFBLE1BQUFBLE9BQUFBO0FBRTVDLE1BQU1DLGVBQWUsQ0FBZUMsUUFBb0IsRUFBRSxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ0Y7QUFFdEUsSUFBSUc7QUFDSixJQUFJQyxnQkFBb0NDO0FBQ3hDLElBQUlDO0FBQ0osSUFBSUM7QUFDSixJQUFJQztBQUNKLElBQUlDO0FBS0osSUFBSUMsMkJBQTJCO0FBQy9CLElBQUlDO0FBRUosSUFBSUM7QUFDSixJQUFJQztBQUVKLElBQUlDLFdBQXlCQztBQUM3QixJQUFJQztBQUVKLE1BQU1DLGtCQUFrQkMsT0FBQUEsT0FBSyxDQUFDQyxTQUFTO0lBSXJDQyxrQkFBa0JDLFlBQW1CLEVBQUVDLElBQVMsRUFBRTtRQUNoRCxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsRUFBRSxDQUFDSCxjQUFjQztJQUM5QjtJQUVBRyxvQkFBb0I7UUFDbEIsSUFBSSxDQUFDQyxZQUFZO1FBRWpCLDBDQUEwQztRQUMxQyx5RUFBeUU7UUFDekUsb0VB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O2dCQUM5QjtZQUNGLE9BR0s7Z0JBQ0hsTyxXQUFXO29CQUNULE1BQU13TTtnQkFDUjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLElBQUkxTCxPQUFPdU4sbUJBQW1CLEVBQUU7UUFDOUIsTUFBTXZOLE9BQU91TixtQkFBbUIsQ0FBQ3ZSLFlBQVl3UixVQUFVO0lBQ3pEO0lBRUFsUyxTQUFTbVMsQ0FBQUEsR0FBQUEsUUFBQUEsWUFBQUEsRUFBYXpSLFlBQVlzSSxJQUFJLEVBQUV0SSxZQUFZcUMsS0FBSyxFQUFFbEMsUUFBUTtRQUNqRXVSLGNBQWMxUixZQUFZb0IsS0FBSztRQUMvQmhCO1FBQ0FrRyxLQUFLM0Y7UUFDTEssV0FBV0g7UUFDWGlIO1FBQ0FwRixLQUFLZ047UUFDTGpPLFlBQVlrUSxRQUFRM1IsWUFBWXlCLFVBQVU7UUFDMUNtUSxjQUFjLENBQUN6USxNQUFNbUYsS0FBS29JLFNBQ3hCdEwsT0FDRXlPLE9BQU8xUCxNQUFNLENBSVgsQ0FBQyxHQUFHaEIsTUFBTTtnQkFDVm1GO2dCQUNBb0k7WUFDRjtRQUVKeEosUUFBUWxGLFlBQVlrRixNQUFNO1FBQzFCSixTQUFTOUUsWUFBWThFLE9BQU87UUFDNUI3RTtRQUNBNlIsZUFBZTlSLFlBQVk4UixhQUFhO1FBQ3hDQyxXQUFXL1IsWUFBWStSLFNBQVM7SUFDbEM7SUFFQXhSLDJCQUEyQixNQUFNakIsT0FBTzBTLGdDQUFnQztJQUV4RSxNQUFNQyxZQUE2QjtRQUNqQzNMLEtBQUszRjtRQUNMdVIsU0FBUztRQUNUbFIsV0FBV0g7UUFDWE8sT0FBT3BCLFlBQVlvQixLQUFLO1FBQ3hCc0IsS0FBS2dOO1FBQ0xILGVBQWU7SUFDakI7SUFFQSxJQUFJOUwsTUFBTThGLGNBQWM7UUFDdEIsTUFBTTlGLEtBQUs4RixZQUFZO0lBQ3pCO0lBRUFuRyxPQUFPNk87QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL3NhbnNrcml0aWtoYW5hbC9EZXNrdG9wL0Fzc2lnbm1lbnQvQ2luZWdoYXItV2ViL3NyYy9jbGllbnQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBsb2NhdGlvbiAqL1xuLy8gaW1wb3J0cyBwb2x5ZmlsbCBmcm9tIGBAbmV4dC9wb2x5ZmlsbC1tb2R1bGVgIGFmdGVyIGJ1aWxkLlxuaW1wb3J0ICcuLi9idWlsZC9wb2x5ZmlsbHMvcG9seWZpbGwtbW9kdWxlJ1xuaW1wb3J0IHR5cGUgUm91dGVyIGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB0eXBlIHtcbiAgQXBwQ29tcG9uZW50LFxuICBBcHBQcm9wcyxcbiAgUHJpdmF0ZVJvdXRlSW5mbyxcbn0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyJ1xuXG5pbXBvcnQgUmVhY3QsIHsgdHlwZSBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20vY2xpZW50J1xuaW1wb3J0IHsgSGVhZE1hbmFnZXJDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCBtaXR0IGZyb20gJy4uL3NoYXJlZC9saWIvbWl0dCdcbmltcG9ydCB0eXBlIHsgTWl0dEVtaXR0ZXIgfSBmcm9tICcuLi9zaGFyZWQvbGliL21pdHQnXG5pbXBvcnQgeyBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZSdcbmltcG9ydCB7IGRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24gfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9kaXNhYmxlLXNtb290aC1zY3JvbGwnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQge1xuICB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zLFxuICBhc3NpZ24sXG59IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgZ2V0VVJMLCBsb2FkR2V0SW5pdGlhbFByb3BzLCBTVCB9IGZyb20gJy4uL3NoYXJlZC9saWIvdXRpbHMnXG5pbXBvcnQgdHlwZSB7IE5leHRXZWJWaXRhbHNNZXRyaWMsIE5FWFRfREFUQSB9IGZyb20gJy4uL3NoYXJlZC9saWIvdXRpbHMnXG5pbXBvcnQgeyBQb3J0YWwgfSBmcm9tICcuL3BvcnRhbCdcbmltcG9ydCBpbml0SGVhZE1hbmFnZXIgZnJvbSAnLi9oZWFkLW1hbmFnZXInXG5pbXBvcnQgUGFnZUxvYWRlciBmcm9tICcuL3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IHR5cGUgeyBTdHlsZVNoZWV0VHVwbGUgfSBmcm9tICcuL3BhZ2UtbG9hZGVyJ1xuaW1wb3J0IHsgUm91dGVBbm5vdW5jZXIgfSBmcm9tICcuL3JvdXRlLWFubm91bmNlcidcbmltcG9ydCB7IGNyZWF0ZVJvdXRlciwgbWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIH0gZnJvbSAnLi9yb3V0ZXInXG5pbXBvcnQgeyBnZXRQcm9wZXJFcnJvciB9IGZyb20gJy4uL2xpYi9pcy1lcnJvcidcbmltcG9ydCB7IEltYWdlQ29uZmlnQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgdHlwZSB7IEltYWdlQ29uZmlnQ29tcGxldGUgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZydcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi9yZW1vdmUtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuL2hhcy1iYXNlLXBhdGgnXG5pbXBvcnQgeyBBcHBSb3V0ZXJDb250ZXh0IH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9hcHAtcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQge1xuICBhZGFwdEZvckFwcFJvdXRlckluc3RhbmNlLFxuICBhZGFwdEZvclBhdGhQYXJhbXMsXG4gIGFkYXB0Rm9yU2VhcmNoUGFyYW1zLFxuICBQYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXIsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL2FkYXB0ZXJzJ1xuaW1wb3J0IHtcbiAgU2VhcmNoUGFyYW1zQ29udGV4dCxcbiAgUGF0aFBhcmFtc0NvbnRleHQsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUnXG5pbXBvcnQgeyBvblJlY292ZXJhYmxlRXJyb3IgfSBmcm9tICcuL3JlYWN0LWNsaWVudC1jYWxsYmFja3Mvb24tcmVjb3ZlcmFibGUtZXJyb3InXG5pbXBvcnQgdHJhY2VyIGZyb20gJy4vdHJhY2luZy90cmFjZXInXG5pbXBvcnQgeyBpc05leHRSb3V0ZXJFcnJvciB9IGZyb20gJy4vY29tcG9uZW50cy9pcy1uZXh0LXJvdXRlci1lcnJvcidcblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJyZWFjdC1kb20vZXhwZXJpbWVudGFsXCIgLz5cblxuZGVjbGFyZSBnbG9iYWwge1xuICBpbnRlcmZhY2UgV2luZG93IHtcbiAgICAvKiB0ZXN0IGZucyAqL1xuICAgIF9fTkVYVF9IWURSQVRFRD86IGJvb2xlYW5cbiAgICBfX05FWFRfSFlEUkFURURfQVQ/OiBudW1iZXJcbiAgICBfX05FWFRfSFlEUkFURURfQ0I/OiAoKSA9PiB2b2lkXG5cbiAgICAvKiBwcm9kICovXG4gICAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gICAgX19ORVhUX1A6IGFueVtdXG4gIH1cbn1cbnR5cGUgUmVuZGVyUm91dGVJbmZvID0gUHJpdmF0ZVJvdXRlSW5mbyAmIHtcbiAgQXBwOiBBcHBDb21wb25lbnRcbiAgc2Nyb2xsPzogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuICBpc0h5ZHJhdGVQYXNzPzogYm9vbGVhblxufVxudHlwZSBSZW5kZXJFcnJvclByb3BzID0gT21pdDxSZW5kZXJSb3V0ZUluZm8sICdDb21wb25lbnQnIHwgJ3N0eWxlU2hlZXRzJz5cbnR5cGUgUmVnaXN0ZXJGbiA9IChpbnB1dDogW3N0cmluZywgKCkgPT4gdm9pZF0pID0+IHZvaWRcblxuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBwcm9jZXNzLmVudi5fX05FWFRfVkVSU0lPTlxuZXhwb3J0IGxldCByb3V0ZXI6IFJvdXRlclxuZXhwb3J0IGNvbnN0IGVtaXR0ZXI6IE1pdHRFbWl0dGVyPHN0cmluZz4gPSBtaXR0KClcblxuY29uc3QgbG9vc2VUb0FycmF5ID0gPFQgZXh0ZW5kcyB7fT4oaW5wdXQ6IGFueSk6IFRbXSA9PiBbXS5zbGljZS5jYWxsKGlucHV0KVxuXG5sZXQgaW5pdGlhbERhdGE6IE5FWFRfREFUQVxubGV0IGRlZmF1bHRMb2NhbGU6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxubGV0IGFzUGF0aDogc3RyaW5nXG5sZXQgcGFnZUxvYWRlcjogUGFnZUxvYWRlclxubGV0IGFwcEVsZW1lbnQ6IEhUTUxFbGVtZW50IHwgbnVsbFxubGV0IGhlYWRNYW5hZ2VyOiB7XG4gIG1vdW50ZWRJbnN0YW5jZXM6IFNldDx1bmtub3duPlxuICB1cGRhdGVIZWFkOiAoaGVhZDogSlNYLkVsZW1lbnRbXSkgPT4gdm9pZFxuICBnZXRJc1Nzcj86ICgpID0+IGJvb2xlYW5cbn1cbmxldCBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUgPSBmYWxzZVxubGV0IGxhc3RBcHBQcm9wczogQXBwUHJvcHNcblxubGV0IGxhc3RSZW5kZXJSZWplY3Q6ICgoKSA9PiB2b2lkKSB8IG51bGxcbmxldCBkZXZDbGllbnQ6IGFueVxuXG5sZXQgQ2FjaGVkQXBwOiBBcHBDb21wb25lbnQsIG9uUGVyZkVudHJ5OiAobWV0cmljOiBhbnkpID0+IHZvaWRcbmxldCBDYWNoZWRDb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudFR5cGVcblxuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50PHtcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGVcbiAgZm46IChlcnI6IEVycm9yLCBpbmZvPzogYW55KSA9PiB2b2lkXG59PiB7XG4gIGNvbXBvbmVudERpZENhdGNoKGNvbXBvbmVudEVycjogRXJyb3IsIGluZm86IGFueSkge1xuICAgIHRoaXMucHJvcHMuZm4oY29tcG9uZW50RXJyLCBpbmZvKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5zY3JvbGxUb0hhc2goKVxuXG4gICAgLy8gV2UgbmVlZCB0byByZXBsYWNlIHRoZSByb3V0ZXIgc3RhdGUgaWY6XG4gICAgLy8gLSB0aGUgcGFnZSB3YXMgKGF1dG8pIGV4cG9ydGVkIGFuZCBoYXMgYSBxdWVyeSBzdHJpbmcgb3Igc2VhcmNoIChoYXNoKVxuICAgIC8vIC0gaXQgd2FzIGF1dG8gZXhwb3J0ZWQgYW5kIGlzIGEgZHluYW1pYyByb3V0ZSAodG8gcHJvdmlkZSBwYXJhbXMpXG4gICAgLy8gLSBpZiBpdCBpcyBhIGNsaWVudC1zaWRlIHNrZWxldG9uIChmYWxsYmFjayByZW5kZXIpXG4gICAgLy8gLSBpZiBtaWRkbGV3YXJlIG1hdGNoZXMgdGhlIGN1cnJlbnQgcGFnZSAobWF5IGhhdmUgcmV3cml0ZSBwYXJhbXMpXG4gICAgLy8gLSBpZiByZXdyaXRlcyBpbiBuZXh0LmNvbmZpZy5qcyBtYXRjaCAobWF5IGhhdmUgcmV3cml0ZSBwYXJhbXMpXG4gICAgaWYgKFxuICAgICAgcm91dGVyLmlzU3NyICYmXG4gICAgICAoaW5pdGlhbERhdGEuaXNGYWxsYmFjayB8fFxuICAgICAgICAoaW5pdGlhbERhdGEubmV4dEV4cG9ydCAmJlxuICAgICAgICAgIChpc0R5bmFtaWNSb3V0ZShyb3V0ZXIucGF0aG5hbWUpIHx8XG4gICAgICAgICAgICBsb2NhdGlvbi5zZWFyY2ggfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgfHxcbiAgICAgICAgICAgIGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSkpIHx8XG4gICAgICAgIChpbml0aWFsRGF0YS5wcm9wcyAmJlxuICAgICAgICAgIGluaXRpYWxEYXRhLnByb3BzLl9fTl9TU0cgJiZcbiAgICAgICAgICAobG9jYXRpb24uc2VhcmNoIHx8XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTIHx8XG4gICAgICAgICAgICBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUpKSlcbiAgICApIHtcbiAgICAgIC8vIHVwZGF0ZSBxdWVyeSBvbiBtb3VudCBmb3IgZXhwb3J0ZWQgcGFnZXNcbiAgICAgIHJvdXRlclxuICAgICAgICAucmVwbGFjZShcbiAgICAgICAgICByb3V0ZXIucGF0aG5hbWUgK1xuICAgICAgICAgICAgJz8nICtcbiAgICAgICAgICAgIFN0cmluZyhcbiAgICAgICAgICAgICAgYXNzaWduKFxuICAgICAgICAgICAgICAgIHVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocm91dGVyLnF1ZXJ5KSxcbiAgICAgICAgICAgICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLy8gV0FSTklORzogYF9oYCBpcyBhbiBpbnRlcm5hbCBvcHRpb24gZm9yIGhhbmRpbmcgTmV4dC5qc1xuICAgICAgICAgICAgLy8gY2xpZW50LXNpZGUgaHlkcmF0aW9uLiBZb3VyIGFwcCBzaG91bGQgX25ldmVyXyB1c2UgdGhpcyBwcm9wZXJ0eS5cbiAgICAgICAgICAgIC8vIEl0IG1heSBjaGFuZ2UgYXQgYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgICAgICBfaDogMSxcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHBhZ2VzIG11c3QgdHJpZ2dlciB0aGUgZGF0YSBmZXRjaCwgc28gdGhlIHRyYW5zaXRpb24gaXNcbiAgICAgICAgICAgIC8vIG5vdCBzaGFsbG93LlxuICAgICAgICAgICAgLy8gT3RoZXIgcGFnZXMgKHN0cmljdGx5IHVwZGF0aW5nIHF1ZXJ5KSBoYXBwZW5zIHNoYWxsb3dseSwgYXMgZGF0YVxuICAgICAgICAgICAgLy8gcmVxdWlyZW1lbnRzIHdvdWxkIGFscmVhZHkgYmUgcHJlc2VudC5cbiAgICAgICAgICAgIHNoYWxsb3c6ICFpbml0aWFsRGF0YS5pc0ZhbGxiYWNrICYmICFpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUsXG4gICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgaWYgKCFlcnIuY2FuY2VsbGVkKSB0aHJvdyBlcnJcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy5zY3JvbGxUb0hhc2goKVxuICB9XG5cbiAgc2Nyb2xsVG9IYXNoKCkge1xuICAgIGxldCB7IGhhc2ggfSA9IGxvY2F0aW9uXG4gICAgaGFzaCA9IGhhc2ggJiYgaGFzaC5zdWJzdHJpbmcoMSlcbiAgICBpZiAoIWhhc2gpIHJldHVyblxuXG4gICAgY29uc3QgZWw6IEhUTUxFbGVtZW50IHwgbnVsbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpXG4gICAgaWYgKCFlbCkgcmV0dXJuXG5cbiAgICAvLyBJZiB3ZSBjYWxsIHNjcm9sbEludG9WaWV3KCkgaW4gaGVyZSB3aXRob3V0IGEgc2V0VGltZW91dFxuICAgIC8vIGl0IHdvbid0IHNjcm9sbCBwcm9wZXJseS5cbiAgICBzZXRUaW1lb3V0KCgpID0+IGVsLnNjcm9sbEludG9WaWV3KCksIDApXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHsgUGFnZXNEZXZPdmVybGF5QnJpZGdlIH0gPVxuICAgICAgICByZXF1aXJlKCcuLi9uZXh0LWRldnRvb2xzL3VzZXJzcGFjZS9wYWdlcy9wYWdlcy1kZXYtb3ZlcmxheS1zZXR1cCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL25leHQtZGV2dG9vbHMvdXNlcnNwYWNlL3BhZ2VzL3BhZ2VzLWRldi1vdmVybGF5LXNldHVwJylcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxQYWdlc0Rldk92ZXJsYXlCcmlkZ2U+e3RoaXMucHJvcHMuY2hpbGRyZW59PC9QYWdlc0Rldk92ZXJsYXlCcmlkZ2U+XG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKG9wdHM6IHsgZGV2Q2xpZW50PzogYW55IH0gPSB7fSk6IFByb21pc2U8e1xuICBhc3NldFByZWZpeDogc3RyaW5nXG59PiB7XG4gIC8vIFRoaXMgbWFrZXMgc3VyZSB0aGlzIHNwZWNpZmljIGxpbmVzIGFyZSByZW1vdmVkIGluIHByb2R1Y3Rpb25cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgdHJhY2VyLm9uU3BhbkVuZChcbiAgICAgIChcbiAgICAgICAgcmVxdWlyZSgnLi90cmFjaW5nL3JlcG9ydC10by1zb2NrZXQnKSBhcyB0eXBlb2YgaW1wb3J0KCcuL3RyYWNpbmcvcmVwb3J0LXRvLXNvY2tldCcpXG4gICAgICApLmRlZmF1bHRcbiAgICApXG4gICAgZGV2Q2xpZW50ID0gb3B0cy5kZXZDbGllbnRcbiAgfVxuXG4gIGluaXRpYWxEYXRhID0gSlNPTi5wYXJzZShcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19ORVhUX0RBVEFfXycpIS50ZXh0Q29udGVudCFcbiAgKVxuICB3aW5kb3cuX19ORVhUX0RBVEFfXyA9IGluaXRpYWxEYXRhXG5cbiAgZGVmYXVsdExvY2FsZSA9IGluaXRpYWxEYXRhLmRlZmF1bHRMb2NhbGVcbiAgY29uc3QgcHJlZml4OiBzdHJpbmcgPSBpbml0aWFsRGF0YS5hc3NldFByZWZpeCB8fCAnJ1xuICAvLyBXaXRoIGR5bmFtaWMgYXNzZXRQcmVmaXggaXQncyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0IGFzc2V0UHJlZml4IGF0IHRoZSBidWlsZCB0aW1lXG4gIC8vIFNvLCB0aGlzIGlzIGhvdyB3ZSBkbyBpdCBpbiB0aGUgY2xpZW50IHNpZGUgYXQgcnVudGltZVxuICA7KHNlbGYgYXMgYW55KS5fX25leHRfc2V0X3B1YmxpY19wYXRoX18oYCR7cHJlZml4fS9fbmV4dC9gKVxuXG4gIGFzUGF0aCA9IGdldFVSTCgpXG5cbiAgLy8gbWFrZSBzdXJlIG5vdCB0byBhdHRlbXB0IHN0cmlwcGluZyBiYXNlUGF0aCBmb3IgNDA0c1xuICBpZiAoaGFzQmFzZVBhdGgoYXNQYXRoKSkge1xuICAgIGFzUGF0aCA9IHJlbW92ZUJhc2VQYXRoKGFzUGF0aClcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgY29uc3QgeyBub3JtYWxpemVMb2NhbGVQYXRoIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL3NoYXJlZC9saWIvaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGgnKVxuXG4gICAgY29uc3QgeyBkZXRlY3REb21haW5Mb2NhbGUgfSA9XG4gICAgICByZXF1aXJlKCcuLi9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9zaGFyZWQvbGliL2kxOG4vZGV0ZWN0LWRvbWFpbi1sb2NhbGUnKVxuXG4gICAgY29uc3QgeyBwYXJzZVJlbGF0aXZlVXJsIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcGFyc2UtcmVsYXRpdmUtdXJsJylcblxuICAgIGNvbnN0IHsgZm9ybWF0VXJsIH0gPVxuICAgICAgcmVxdWlyZSgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCcpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwnKVxuXG4gICAgaWYgKGluaXRpYWxEYXRhLmxvY2FsZXMpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChhc1BhdGgpXG4gICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgIGluaXRpYWxEYXRhLmxvY2FsZXNcbiAgICAgIClcblxuICAgICAgaWYgKGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGUpIHtcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lXG4gICAgICAgIGFzUGF0aCA9IGZvcm1hdFVybChwYXJzZWRBcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlcml2ZSB0aGUgZGVmYXVsdCBsb2NhbGUgaWYgaXQgd2Fzbid0IGRldGVjdGVkIGluIHRoZSBhc1BhdGhcbiAgICAgICAgLy8gc2luY2Ugd2UgZG9uJ3QgcHJlcmVuZGVyIHN0YXRpYyBwYWdlcyB3aXRoIGFsbCBwb3NzaWJsZSBkZWZhdWx0XG4gICAgICAgIC8vIGxvY2FsZXNcbiAgICAgICAgZGVmYXVsdExvY2FsZSA9IGluaXRpYWxEYXRhLmxvY2FsZVxuICAgICAgfVxuXG4gICAgICAvLyBhdHRlbXB0IGRldGVjdGluZyBkZWZhdWx0IGxvY2FsZSBiYXNlZCBvbiBob3N0bmFtZVxuICAgICAgY29uc3QgZGV0ZWN0ZWREb21haW4gPSBkZXRlY3REb21haW5Mb2NhbGUoXG4gICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX0RPTUFJTlMgYXMgYW55LFxuICAgICAgICB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWVcbiAgICAgIClcblxuICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgaWYgZGVmYXVsdExvY2FsZSBuZWVkcyB0byBiZSBwb3B1bGF0ZWQgYWZ0ZXJcbiAgICAgIC8vIGh5ZHJhdGlvbiB0byBwcmV2ZW50IG1pc21hdGNoZWQgcmVuZGVyc1xuICAgICAgaWYgKGRldGVjdGVkRG9tYWluKSB7XG4gICAgICAgIGRlZmF1bHRMb2NhbGUgPSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluaXRpYWxEYXRhLnNjcmlwdExvYWRlcikge1xuICAgIGNvbnN0IHsgaW5pdFNjcmlwdExvYWRlciB9ID1cbiAgICAgIHJlcXVpcmUoJy4vc2NyaXB0JykgYXMgdHlwZW9mIGltcG9ydCgnLi9zY3JpcHQnKVxuICAgIGluaXRTY3JpcHRMb2FkZXIoaW5pdGlhbERhdGEuc2NyaXB0TG9hZGVyKVxuICB9XG5cbiAgcGFnZUxvYWRlciA9IG5ldyBQYWdlTG9hZGVyKGluaXRpYWxEYXRhLmJ1aWxkSWQsIHByZWZpeClcblxuICBjb25zdCByZWdpc3RlcjogUmVnaXN0ZXJGbiA9IChbciwgZl0pID0+XG4gICAgcGFnZUxvYWRlci5yb3V0ZUxvYWRlci5vbkVudHJ5cG9pbnQociwgZilcbiAgaWYgKHdpbmRvdy5fX05FWFRfUCkge1xuICAgIC8vIERlZmVyIHBhZ2UgcmVnaXN0cmF0aW9uIGZvciBhbm90aGVyIHRpY2suIFRoaXMgd2lsbCBpbmNyZWFzZSB0aGUgb3ZlcmFsbFxuICAgIC8vIGxhdGVuY3kgaW4gaHlkcmF0aW5nIHRoZSBwYWdlLCBidXQgcmVkdWNlIHRoZSB0b3RhbCBibG9ja2luZyB0aW1lLlxuICAgIHdpbmRvdy5fX05FWFRfUC5tYXAoKHApID0+IHNldFRpbWVvdXQoKCkgPT4gcmVnaXN0ZXIocCksIDApKVxuICB9XG4gIHdpbmRvdy5fX05FWFRfUCA9IFtdXG4gIDsod2luZG93Ll9fTkVYVF9QIGFzIGFueSkucHVzaCA9IHJlZ2lzdGVyXG5cbiAgaGVhZE1hbmFnZXIgPSBpbml0SGVhZE1hbmFnZXIoKVxuICBoZWFkTWFuYWdlci5nZXRJc1NzciA9ICgpID0+IHtcbiAgICByZXR1cm4gcm91dGVyLmlzU3NyXG4gIH1cblxuICBhcHBFbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ19fbmV4dCcpXG4gIHJldHVybiB7IGFzc2V0UHJlZml4OiBwcmVmaXggfVxufVxuXG5mdW5jdGlvbiByZW5kZXJBcHAoQXBwOiBBcHBDb21wb25lbnQsIGFwcFByb3BzOiBBcHBQcm9wcykge1xuICByZXR1cm4gPEFwcCB7Li4uYXBwUHJvcHN9IC8+XG59XG5cbmZ1bmN0aW9uIEFwcENvbnRhaW5lcih7XG4gIGNoaWxkcmVuLFxufTogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e30+KTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgLy8gQ3JlYXRlIGEgbWVtb2l6ZWQgdmFsdWUgZm9yIG5leHQvbmF2aWdhdGlvbiByb3V0ZXIgY29udGV4dC5cbiAgY29uc3QgYWRhcHRlZEZvckFwcFJvdXRlciA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIHJldHVybiBhZGFwdEZvckFwcFJvdXRlckluc3RhbmNlKHJvdXRlcilcbiAgfSwgW10pXG4gIHJldHVybiAoXG4gICAgPENvbnRhaW5lclxuICAgICAgZm49eyhlcnJvcikgPT5cbiAgICAgICAgcmVuZGVyRXJyb3IoeyBBcHA6IENhY2hlZEFwcCwgZXJyOiBlcnJvciB9KS5jYXRjaCgoZXJyKSA9PlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmRlcmluZyBwYWdlOiAnLCBlcnIpXG4gICAgICAgIClcbiAgICAgIH1cbiAgICA+XG4gICAgICA8QXBwUm91dGVyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17YWRhcHRlZEZvckFwcFJvdXRlcn0+XG4gICAgICAgIDxTZWFyY2hQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXthZGFwdEZvclNlYXJjaFBhcmFtcyhyb3V0ZXIpfT5cbiAgICAgICAgICA8UGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyXG4gICAgICAgICAgICByb3V0ZXI9e3JvdXRlcn1cbiAgICAgICAgICAgIGlzQXV0b0V4cG9ydD17c2VsZi5fX05FWFRfREFUQV9fLmF1dG9FeHBvcnQgPz8gZmFsc2V9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPFBhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXthZGFwdEZvclBhdGhQYXJhbXMocm91dGVyKX0+XG4gICAgICAgICAgICAgIDxSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXttYWtlUHVibGljUm91dGVySW5zdGFuY2Uocm91dGVyKX0+XG4gICAgICAgICAgICAgICAgPEhlYWRNYW5hZ2VyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17aGVhZE1hbmFnZXJ9PlxuICAgICAgICAgICAgICAgICAgPEltYWdlQ29uZmlnQ29udGV4dC5Qcm92aWRlclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZT17XG4gICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnZcbiAgICAgICAgICAgICAgICAgICAgICAgIC5fX05FWFRfSU1BR0VfT1BUUyBhcyBhbnkgYXMgSW1hZ2VDb25maWdDb21wbGV0ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAgICAgIDwvSW1hZ2VDb25maWdDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgICAgIDwvSGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAgICA8L1JvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICA8L1BhdGhQYXJhbXNDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgIDwvUGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyPlxuICAgICAgICA8L1NlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L0FwcFJvdXRlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgPC9Db250YWluZXI+XG4gIClcbn1cblxuY29uc3Qgd3JhcEFwcCA9XG4gIChBcHA6IEFwcENvbXBvbmVudCkgPT5cbiAgKHdyYXBwZWRBcHBQcm9wczogUmVjb3JkPHN0cmluZywgYW55Pik6IEpTWC5FbGVtZW50ID0+IHtcbiAgICBjb25zdCBhcHBQcm9wczogQXBwUHJvcHMgPSB7XG4gICAgICAuLi53cmFwcGVkQXBwUHJvcHMsXG4gICAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICAgIGVycjogaW5pdGlhbERhdGEuZXJyLFxuICAgICAgcm91dGVyLFxuICAgIH1cbiAgICByZXR1cm4gPEFwcENvbnRhaW5lcj57cmVuZGVyQXBwKEFwcCwgYXBwUHJvcHMpfTwvQXBwQ29udGFpbmVyPlxuICB9XG5cbi8vIFRoaXMgbWV0aG9kIGhhbmRsZXMgYWxsIHJ1bnRpbWUgYW5kIGRlYnVnIGVycm9ycy5cbi8vIDQwNCBhbmQgNTAwIGVycm9ycyBhcmUgc3BlY2lhbCBraW5kIG9mIGVycm9yc1xuLy8gYW5kIHRoZXkgYXJlIHN0aWxsIGhhbmRsZSB2aWEgdGhlIG1haW4gcmVuZGVyIG1ldGhvZC5cbmZ1bmN0aW9uIHJlbmRlckVycm9yKHJlbmRlckVycm9yUHJvcHM6IFJlbmRlckVycm9yUHJvcHMpOiBQcm9taXNlPGFueT4ge1xuICBsZXQgeyBBcHAsIGVyciB9ID0gcmVuZGVyRXJyb3JQcm9wc1xuXG4gIC8vIEluIGRldmVsb3BtZW50IHJ1bnRpbWUgZXJyb3JzIGFyZSBjYXVnaHQgYnkgb3VyIG92ZXJsYXlcbiAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBBIE5leHQuanMgcmVuZGVyaW5nIHJ1bnRpbWUgZXJyb3IgaXMgYWx3YXlzIHVucmVjb3ZlcmFibGVcbiAgICAvLyBGSVhNRTogbGV0J3MgbWFrZSB0aGlzIHJlY292ZXJhYmxlIChlcnJvciBpbiBHSVAgY2xpZW50LXRyYW5zaXRpb24pXG4gICAgZGV2Q2xpZW50Lm9uVW5yZWNvdmVyYWJsZUVycm9yKClcblxuICAgIC8vIFdlIG5lZWQgdG8gcmVuZGVyIGFuIGVtcHR5IDxBcHA+IHNvIHRoYXQgdGhlIGA8UmVhY3REZXZPdmVybGF5PmAgY2FuXG4gICAgLy8gcmVuZGVyIGl0c2VsZi5cbiAgICByZXR1cm4gZG9SZW5kZXIoe1xuICAgICAgQXBwOiAoKSA9PiBudWxsLFxuICAgICAgcHJvcHM6IHt9LFxuICAgICAgQ29tcG9uZW50OiAoKSA9PiBudWxsLFxuICAgICAgc3R5bGVTaGVldHM6IFtdLFxuICAgIH0pXG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZSwgb3RoZXJ3aXNlIHVzZXJzIGNhbid0IHRyYWNrIGRvd24gaXNzdWVzLlxuICBjb25zb2xlLmVycm9yKGVycilcbiAgY29uc29sZS5lcnJvcihcbiAgICBgQSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkLCBzZWUgaGVyZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9jbGllbnQtc2lkZS1leGNlcHRpb24tb2NjdXJyZWRgXG4gIClcblxuICByZXR1cm4gcGFnZUxvYWRlclxuICAgIC5sb2FkUGFnZSgnL19lcnJvcicpXG4gICAgLnRoZW4oKHsgcGFnZTogRXJyb3JDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0pID0+IHtcbiAgICAgIHJldHVybiBsYXN0QXBwUHJvcHM/LkNvbXBvbmVudCA9PT0gRXJyb3JDb21wb25lbnRcbiAgICAgICAgPyBpbXBvcnQoJy4uL3BhZ2VzL19lcnJvcicpXG4gICAgICAgICAgICAudGhlbigoZXJyb3JNb2R1bGUpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydCgnLi4vcGFnZXMvX2FwcCcpLnRoZW4oKGFwcE1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgICAgIEFwcCA9IGFwcE1vZHVsZS5kZWZhdWx0IGFzIGFueSBhcyBBcHBDb21wb25lbnRcbiAgICAgICAgICAgICAgICByZW5kZXJFcnJvclByb3BzLkFwcCA9IEFwcFxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck1vZHVsZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChtKSA9PiAoe1xuICAgICAgICAgICAgICBFcnJvckNvbXBvbmVudDogbS5kZWZhdWx0IGFzIFJlYWN0LkNvbXBvbmVudFR5cGU8e30+LFxuICAgICAgICAgICAgICBzdHlsZVNoZWV0czogW10sXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgOiB7IEVycm9yQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9XG4gICAgfSlcbiAgICAudGhlbigoeyBFcnJvckNvbXBvbmVudCwgc3R5bGVTaGVldHMgfSkgPT4ge1xuICAgICAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBkbyBhIG5vcm1hbCByZW5kZXIgd2l0aCB0aGUgYEVycm9yQ29tcG9uZW50YCBhcyBjb21wb25lbnQuXG4gICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gaGVyZSB1cG9uIGluaXRpYWwgcmVuZGVyLCB3ZSBjYW4gdXNlIHRoZSBwcm9wcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY2FsbCBgZ2V0SW5pdGlhbFByb3BzYCBvbiBgQXBwYCBiZWZvcmUgbW91bnRpbmcuXG4gICAgICBjb25zdCBBcHBUcmVlID0gd3JhcEFwcChBcHApXG4gICAgICBjb25zdCBhcHBDdHggPSB7XG4gICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgIEFwcFRyZWUsXG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgY3R4OiB7XG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIHBhdGhuYW1lOiBpbml0aWFsRGF0YS5wYWdlLFxuICAgICAgICAgIHF1ZXJ5OiBpbml0aWFsRGF0YS5xdWVyeSxcbiAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIHJlbmRlckVycm9yUHJvcHMucHJvcHM/LmVyclxuICAgICAgICAgID8gcmVuZGVyRXJyb3JQcm9wcy5wcm9wc1xuICAgICAgICAgIDogbG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIGFwcEN0eClcbiAgICAgICkudGhlbigoaW5pdFByb3BzKSA9PlxuICAgICAgICBkb1JlbmRlcih7XG4gICAgICAgICAgLi4ucmVuZGVyRXJyb3JQcm9wcyxcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICBwcm9wczogaW5pdFByb3BzLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG59XG5cbi8vIER1bW15IGNvbXBvbmVudCB0aGF0IHdlIHJlbmRlciBhcyBhIGNoaWxkIG9mIFJvb3Qgc28gdGhhdCB3ZSBjYW5cbi8vIHRvZ2dsZSB0aGUgY29ycmVjdCBzdHlsZXMgYmVmb3JlIHRoZSBwYWdlIGlzIHJlbmRlcmVkLlxuZnVuY3Rpb24gSGVhZCh7IGNhbGxiYWNrIH06IHsgY2FsbGJhY2s6ICgpID0+IHZvaWQgfSk6IG51bGwge1xuICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZS5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGNhbGxiYWNrKCksIFtjYWxsYmFja10pXG4gIHJldHVybiBudWxsXG59XG5cbmNvbnN0IHBlcmZvcm1hbmNlTWFya3MgPSB7XG4gIG5hdmlnYXRpb25TdGFydDogJ25hdmlnYXRpb25TdGFydCcsXG4gIGJlZm9yZVJlbmRlcjogJ2JlZm9yZVJlbmRlcicsXG4gIGFmdGVyUmVuZGVyOiAnYWZ0ZXJSZW5kZXInLFxuICBhZnRlckh5ZHJhdGU6ICdhZnRlckh5ZHJhdGUnLFxuICByb3V0ZUNoYW5nZTogJ3JvdXRlQ2hhbmdlJyxcbn0gYXMgY29uc3RcblxuY29uc3QgcGVyZm9ybWFuY2VNZWFzdXJlcyA9IHtcbiAgaHlkcmF0aW9uOiAnTmV4dC5qcy1oeWRyYXRpb24nLFxuICBiZWZvcmVIeWRyYXRpb246ICdOZXh0LmpzLWJlZm9yZS1oeWRyYXRpb24nLFxuICByb3V0ZUNoYW5nZVRvUmVuZGVyOiAnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJyxcbiAgcmVuZGVyOiAnTmV4dC5qcy1yZW5kZXInLFxufSBhcyBjb25zdFxuXG5sZXQgcmVhY3RSb290OiBhbnkgPSBudWxsXG4vLyBPbiBpbml0aWFsIHJlbmRlciBhIGh5ZHJhdGUgc2hvdWxkIGFsd2F5cyBoYXBwZW5cbmxldCBzaG91bGRIeWRyYXRlOiBib29sZWFuID0gdHJ1ZVxuXG5mdW5jdGlvbiBjbGVhck1hcmtzKCk6IHZvaWQge1xuICA7W1xuICAgIHBlcmZvcm1hbmNlTWFya3MuYmVmb3JlUmVuZGVyLFxuICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlLFxuICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJSZW5kZXIsXG4gICAgcGVyZm9ybWFuY2VNYXJrcy5yb3V0ZUNoYW5nZSxcbiAgXS5mb3JFYWNoKChtYXJrKSA9PiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKG1hcmspKVxufVxuXG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCk6IHZvaWQge1xuICBpZiAoIVNUKSByZXR1cm5cblxuICBwZXJmb3JtYW5jZS5tYXJrKHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlKSAvLyBtYXJrIGVuZCBvZiBoeWRyYXRpb25cblxuICBjb25zdCBoYXNCZWZvcmVSZW5kZXJNYXJrID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcbiAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICAnbWFyaydcbiAgKS5sZW5ndGhcbiAgaWYgKGhhc0JlZm9yZVJlbmRlck1hcmspIHtcbiAgICBjb25zdCBiZWZvcmVIeWRyYXRpb25NZWFzdXJlID0gcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAgIHBlcmZvcm1hbmNlTWVhc3VyZXMuYmVmb3JlSHlkcmF0aW9uLFxuICAgICAgcGVyZm9ybWFuY2VNYXJrcy5uYXZpZ2F0aW9uU3RhcnQsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlclxuICAgIClcblxuICAgIGNvbnN0IGh5ZHJhdGlvbk1lYXN1cmUgPSBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5oeWRyYXRpb24sXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlXG4gICAgKVxuXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgIC8vIE9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkgZG9uJ3QgcmV0dXJuIGBQZXJmb3JtYW5jZU1lYXN1cmVgcyBmcm9tIGBwZXJmb3JtYW5jZS5tZWFzdXJlKClgXG4gICAgICBiZWZvcmVIeWRyYXRpb25NZWFzdXJlICYmXG4gICAgICBoeWRyYXRpb25NZWFzdXJlXG4gICAgKSB7XG4gICAgICB0cmFjZXJcbiAgICAgICAgLnN0YXJ0U3BhbignbmF2aWdhdGlvbi10by1oeWRyYXRpb24nLCB7XG4gICAgICAgICAgc3RhcnRUaW1lOiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luICsgYmVmb3JlSHlkcmF0aW9uTWVhc3VyZS5zdGFydFRpbWUsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnk6IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAuZW5kKFxuICAgICAgICAgIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gK1xuICAgICAgICAgICAgaHlkcmF0aW9uTWVhc3VyZS5zdGFydFRpbWUgK1xuICAgICAgICAgICAgaHlkcmF0aW9uTWVhc3VyZS5kdXJhdGlvblxuICAgICAgICApXG4gICAgfVxuICB9XG5cbiAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgcGVyZm9ybWFuY2VcbiAgICAgIC5nZXRFbnRyaWVzQnlOYW1lKHBlcmZvcm1hbmNlTWVhc3VyZXMuaHlkcmF0aW9uKVxuICAgICAgLmZvckVhY2gob25QZXJmRW50cnkpXG4gIH1cbiAgY2xlYXJNYXJrcygpXG59XG5cbmZ1bmN0aW9uIG1hcmtSZW5kZXJDb21wbGV0ZSgpOiB2b2lkIHtcbiAgaWYgKCFTVCkgcmV0dXJuXG5cbiAgcGVyZm9ybWFuY2UubWFyayhwZXJmb3JtYW5jZU1hcmtzLmFmdGVyUmVuZGVyKSAvLyBtYXJrIGVuZCBvZiByZW5kZXJcbiAgY29uc3QgbmF2U3RhcnRFbnRyaWVzOiBQZXJmb3JtYW5jZUVudHJ5TGlzdCA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoXG4gICAgcGVyZm9ybWFuY2VNYXJrcy5yb3V0ZUNoYW5nZSxcbiAgICAnbWFyaydcbiAgKVxuXG4gIGlmICghbmF2U3RhcnRFbnRyaWVzLmxlbmd0aCkgcmV0dXJuXG5cbiAgY29uc3QgaGFzQmVmb3JlUmVuZGVyTWFyayA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoXG4gICAgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIsXG4gICAgJ21hcmsnXG4gICkubGVuZ3RoXG5cbiAgaWYgKGhhc0JlZm9yZVJlbmRlck1hcmspIHtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5yb3V0ZUNoYW5nZVRvUmVuZGVyLFxuICAgICAgbmF2U3RhcnRFbnRyaWVzWzBdLm5hbWUsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlclxuICAgIClcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5yZW5kZXIsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJSZW5kZXJcbiAgICApXG4gICAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgICBwZXJmb3JtYW5jZVxuICAgICAgICAuZ2V0RW50cmllc0J5TmFtZShwZXJmb3JtYW5jZU1lYXN1cmVzLnJlbmRlcilcbiAgICAgICAgLmZvckVhY2gob25QZXJmRW50cnkpXG4gICAgICBwZXJmb3JtYW5jZVxuICAgICAgICAuZ2V0RW50cmllc0J5TmFtZShwZXJmb3JtYW5jZU1lYXN1cmVzLnJvdXRlQ2hhbmdlVG9SZW5kZXIpXG4gICAgICAgIC5mb3JFYWNoKG9uUGVyZkVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyTWFya3MoKVxuICA7W1xuICAgIHBlcmZvcm1hbmNlTWVhc3VyZXMucm91dGVDaGFuZ2VUb1JlbmRlcixcbiAgICBwZXJmb3JtYW5jZU1lYXN1cmVzLnJlbmRlcixcbiAgXS5mb3JFYWNoKChtZWFzdXJlKSA9PiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmUpKVxufVxuXG5mdW5jdGlvbiByZW5kZXJSZWFjdEVsZW1lbnQoXG4gIGRvbUVsOiBIVE1MRWxlbWVudCxcbiAgZm46IChjYjogKCkgPT4gdm9pZCkgPT4gSlNYLkVsZW1lbnRcbik6IHZvaWQge1xuICAvLyBtYXJrIHN0YXJ0IG9mIGh5ZHJhdGUvcmVuZGVyXG4gIGlmIChTVCkge1xuICAgIHBlcmZvcm1hbmNlLm1hcmsocGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIpXG4gIH1cblxuICBjb25zdCByZWFjdEVsID0gZm4oc2hvdWxkSHlkcmF0ZSA/IG1hcmtIeWRyYXRlQ29tcGxldGUgOiBtYXJrUmVuZGVyQ29tcGxldGUpXG4gIGlmICghcmVhY3RSb290KSB7XG4gICAgLy8gVW5saWtlIHdpdGggY3JlYXRlUm9vdCwgeW91IGRvbid0IG5lZWQgYSBzZXBhcmF0ZSByb290LnJlbmRlcigpIGNhbGwgaGVyZVxuICAgIHJlYWN0Um9vdCA9IFJlYWN0RE9NLmh5ZHJhdGVSb290KGRvbUVsLCByZWFjdEVsLCB7XG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgfSlcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2hvdWxkSHlkcmF0ZSB2YXJpYWJsZSB3aGVuIFJlYWN0IDE4IGlzIHN0YWJsZSBhcyBpdCBjYW4gZGVwZW5kIG9uIGByZWFjdFJvb3RgIGV4aXN0aW5nXG4gICAgc2hvdWxkSHlkcmF0ZSA9IGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uID0gKFJlYWN0IGFzIGFueSkuc3RhcnRUcmFuc2l0aW9uXG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIHJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbClcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIFJvb3Qoe1xuICBjYWxsYmFja3MsXG4gIGNoaWxkcmVuLFxufTogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e1xuICBjYWxsYmFja3M6IEFycmF5PCgpID0+IHZvaWQ+XG59Pik6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWRcbiAgLy8gYXMgc29vbiBhcyBSZWFjdCBmbHVzaGVzIHRoZSB1cGRhdGVcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KFxuICAgICgpID0+IGNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSksXG4gICAgW2NhbGxiYWNrc11cbiAgKVxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlXG4gICAgICB3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0FUID0gcGVyZm9ybWFuY2Uubm93KClcblxuICAgICAgaWYgKHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9IWURSQVRFRF9DQigpXG4gICAgICB9XG4gICAgfSwgW10pXG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW4gYXMgUmVhY3QuUmVhY3RFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGRvUmVuZGVyKGlucHV0OiBSZW5kZXJSb3V0ZUluZm8pOiBQcm9taXNlPGFueT4ge1xuICBsZXQgeyBBcHAsIENvbXBvbmVudCwgcHJvcHMsIGVyciB9OiBSZW5kZXJSb3V0ZUluZm8gPSBpbnB1dFxuICBsZXQgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdIHwgdW5kZWZpbmVkID1cbiAgICAnaW5pdGlhbCcgaW4gaW5wdXQgPyB1bmRlZmluZWQgOiBpbnB1dC5zdHlsZVNoZWV0c1xuICBDb21wb25lbnQgPSBDb21wb25lbnQgfHwgbGFzdEFwcFByb3BzLkNvbXBvbmVudFxuICBwcm9wcyA9IHByb3BzIHx8IGxhc3RBcHBQcm9wcy5wcm9wc1xuXG4gIGNvbnN0IGFwcFByb3BzOiBBcHBQcm9wcyA9IHtcbiAgICAuLi5wcm9wcyxcbiAgICBDb21wb25lbnQsXG4gICAgZXJyLFxuICAgIHJvdXRlcixcbiAgfVxuICAvLyBsYXN0QXBwUHJvcHMgaGFzIHRvIGJlIHNldCBiZWZvcmUgUmVhY3REb20ucmVuZGVyIHRvIGFjY291bnQgZm9yIFJlYWN0RG9tIHRocm93aW5nIGFuIGVycm9yLlxuICBsYXN0QXBwUHJvcHMgPSBhcHBQcm9wc1xuXG4gIGxldCBjYW5jZWxlZDogYm9vbGVhbiA9IGZhbHNlXG4gIGxldCByZXNvbHZlUHJvbWlzZTogKCkgPT4gdm9pZFxuICBjb25zdCByZW5kZXJQcm9taXNlID0gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChsYXN0UmVuZGVyUmVqZWN0KSB7XG4gICAgICBsYXN0UmVuZGVyUmVqZWN0KClcbiAgICB9XG4gICAgcmVzb2x2ZVByb21pc2UgPSAoKSA9PiB7XG4gICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbFxuICAgICAgcmVzb2x2ZSgpXG4gICAgfVxuICAgIGxhc3RSZW5kZXJSZWplY3QgPSAoKSA9PiB7XG4gICAgICBjYW5jZWxlZCA9IHRydWVcbiAgICAgIGxhc3RSZW5kZXJSZWplY3QgPSBudWxsXG5cbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoJ0NhbmNlbCByZW5kZXJpbmcgcm91dGUnKVxuICAgICAgZXJyb3IuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgcmVqZWN0KGVycm9yKVxuICAgIH1cbiAgfSlcblxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyBhIHJldHVybiB0eXBlIHRvIGVuc3VyZSBpdCBkb2Vzbid0IHN0YXJ0IHJldHVybmluZyBhXG4gIC8vIFByb21pc2UuIEl0IHNob3VsZCByZW1haW4gc3luY2hyb25vdXMuXG4gIGZ1bmN0aW9uIG9uU3RhcnQoKTogYm9vbGVhbiB7XG4gICAgaWYgKFxuICAgICAgIXN0eWxlU2hlZXRzIHx8XG4gICAgICAvLyBXZSB1c2UgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFN0eWxlVGFnczogSFRNTFN0eWxlRWxlbWVudFtdID0gbG9vc2VUb0FycmF5PEhUTUxTdHlsZUVsZW1lbnQ+KFxuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1uLWhyZWZdJylcbiAgICApXG4gICAgY29uc3QgY3VycmVudEhyZWZzOiBTZXQ8c3RyaW5nIHwgbnVsbD4gPSBuZXcgU2V0KFxuICAgICAgY3VycmVudFN0eWxlVGFncy5tYXAoKHRhZykgPT4gdGFnLmdldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnKSlcbiAgICApXG5cbiAgICBjb25zdCBub3NjcmlwdDogRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgJ25vc2NyaXB0W2RhdGEtbi1jc3NdJ1xuICAgIClcbiAgICBjb25zdCBub25jZTogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCA9XG4gICAgICBub3NjcmlwdD8uZ2V0QXR0cmlidXRlKCdkYXRhLW4tY3NzJylcblxuICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiwgdGV4dCB9OiB7IGhyZWY6IHN0cmluZzsgdGV4dDogYW55IH0pID0+IHtcbiAgICAgIGlmICghY3VycmVudEhyZWZzLmhhcyhocmVmKSkge1xuICAgICAgICBjb25zdCBzdHlsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicsIGhyZWYpXG4gICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnbWVkaWEnLCAneCcpXG5cbiAgICAgICAgaWYgKG5vbmNlKSB7XG4gICAgICAgICAgc3R5bGVUYWcuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKVxuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZylcbiAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCkpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gb25IZWFkQ29tbWl0KCk6IHZvaWQge1xuICAgIGlmIChcbiAgICAgIC8vIFR1cmJvcGFjayBoYXMgaXQncyBvd24gY3NzIGluamVjdGlvbiBoYW5kbGluZywgdGhpcyBjb2RlIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIENTUy5cbiAgICAgICFwcm9jZXNzLmVudi5UVVJCT1BBQ0sgJiZcbiAgICAgIC8vIFdlIHVzZSBgc3R5bGUtbG9hZGVyYCBpbiBkZXZlbG9wbWVudCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgLy8gdW5sZXNzIHdlJ3JlIGluIHByb2R1Y3Rpb246XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAvLyBXZSBjYW4gc2tpcCB0aGlzIGR1cmluZyBoeWRyYXRpb24uIFJ1bm5pbmcgaXQgd29udCBjYXVzZSBhbnkgaGFybSwgYnV0XG4gICAgICAvLyB3ZSBtYXkgYXMgd2VsbCBzYXZlIHRoZSBDUFUgY3ljbGVzOlxuICAgICAgc3R5bGVTaGVldHMgJiZcbiAgICAgIC8vIEVuc3VyZSB0aGlzIHJlbmRlciB3YXMgbm90IGNhbmNlbGVkXG4gICAgICAhY2FuY2VsZWRcbiAgICApIHtcbiAgICAgIGNvbnN0IGRlc2lyZWRIcmVmczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KHN0eWxlU2hlZXRzLm1hcCgocykgPT4gcy5ocmVmKSlcbiAgICAgIGNvbnN0IGN1cnJlbnRTdHlsZVRhZ3M6IEhUTUxTdHlsZUVsZW1lbnRbXSA9XG4gICAgICAgIGxvb3NlVG9BcnJheTxIVE1MU3R5bGVFbGVtZW50PihcbiAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZVtkYXRhLW4taHJlZl0nKVxuICAgICAgICApXG4gICAgICBjb25zdCBjdXJyZW50SHJlZnM6IHN0cmluZ1tdID0gY3VycmVudFN0eWxlVGFncy5tYXAoXG4gICAgICAgICh0YWcpID0+IHRhZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJykhXG4gICAgICApXG5cbiAgICAgIC8vIFRvZ2dsZSBgPHN0eWxlPmAgdGFncyBvbiBvciBvZmYgZGVwZW5kaW5nIG9uIGlmIHRoZXkncmUgbmVlZGVkOlxuICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgY3VycmVudEhyZWZzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgaWYgKGRlc2lyZWRIcmVmcy5oYXMoY3VycmVudEhyZWZzW2lkeF0pKSB7XG4gICAgICAgICAgY3VycmVudFN0eWxlVGFnc1tpZHhdLnJlbW92ZUF0dHJpYnV0ZSgnbWVkaWEnKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3gnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlb3JkZXIgc3R5bGVzIGludG8gaW50ZW5kZWQgb3JkZXI6XG4gICAgICBsZXQgcmVmZXJlbmNlTm9kZTogRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAnbm9zY3JpcHRbZGF0YS1uLWNzc10nXG4gICAgICApXG4gICAgICBpZiAoXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGFuIGludmFyaWFudDpcbiAgICAgICAgcmVmZXJlbmNlTm9kZVxuICAgICAgKSB7XG4gICAgICAgIHN0eWxlU2hlZXRzLmZvckVhY2goKHsgaHJlZiB9OiB7IGhyZWY6IHN0cmluZyB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0VGFnOiBFbGVtZW50IHwgbnVsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgICBgc3R5bGVbZGF0YS1uLWhyZWY9XCIke2hyZWZ9XCJdYFxuICAgICAgICAgIClcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgICAgICB0YXJnZXRUYWdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUhLnBhcmVudE5vZGUhLmluc2VydEJlZm9yZShcbiAgICAgICAgICAgICAgdGFyZ2V0VGFnLFxuICAgICAgICAgICAgICByZWZlcmVuY2VOb2RlIS5uZXh0U2libGluZ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSA9IHRhcmdldFRhZ1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgLy8gRmluYWxseSwgY2xlYW4gdXAgc2VydmVyIHJlbmRlcmVkIHN0eWxlc2hlZXRzOlxuICAgICAgbG9vc2VUb0FycmF5PEhUTUxMaW5rRWxlbWVudD4oXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbZGF0YS1uLXBdJylcbiAgICAgICkuZm9yRWFjaCgoZWwpID0+IHtcbiAgICAgICAgZWwucGFyZW50Tm9kZSEucmVtb3ZlQ2hpbGQoZWwpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChpbnB1dC5zY3JvbGwpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gaW5wdXQuc2Nyb2xsXG4gICAgICBkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHgsIHkpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUm9vdENvbW1pdCgpOiB2b2lkIHtcbiAgICByZXNvbHZlUHJvbWlzZSgpXG4gIH1cblxuICBvblN0YXJ0KClcblxuICBjb25zdCBlbGVtOiBKU1guRWxlbWVudCA9IChcbiAgICA8PlxuICAgICAgPEhlYWQgY2FsbGJhY2s9e29uSGVhZENvbW1pdH0gLz5cbiAgICAgIDxBcHBDb250YWluZXI+XG4gICAgICAgIHtyZW5kZXJBcHAoQXBwLCBhcHBQcm9wcyl9XG4gICAgICAgIDxQb3J0YWwgdHlwZT1cIm5leHQtcm91dGUtYW5ub3VuY2VyXCI+XG4gICAgICAgICAgPFJvdXRlQW5ub3VuY2VyIC8+XG4gICAgICAgIDwvUG9ydGFsPlxuICAgICAgPC9BcHBDb250YWluZXI+XG4gICAgPC8+XG4gIClcblxuICAvLyBXZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQhLCAoY2FsbGJhY2spID0+IChcbiAgICA8Um9vdCBjYWxsYmFja3M9e1tjYWxsYmFjaywgb25Sb290Q29tbWl0XX0+XG4gICAgICB7cHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gKFxuICAgICAgICA8UmVhY3QuU3RyaWN0TW9kZT57ZWxlbX08L1JlYWN0LlN0cmljdE1vZGU+XG4gICAgICApIDogKFxuICAgICAgICBlbGVtXG4gICAgICApfVxuICAgIDwvUm9vdD5cbiAgKSlcblxuICByZXR1cm4gcmVuZGVyUHJvbWlzZVxufVxuXG5hc3luYyBmdW5jdGlvbiByZW5kZXIocmVuZGVyaW5nUHJvcHM6IFJlbmRlclJvdXRlSW5mbyk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBpZiBhbiBlcnJvciBvY2N1cnMgaW4gYSBzZXJ2ZXItc2lkZSBwYWdlIChlLmcuIGluIGdldEluaXRpYWxQcm9wcyksXG4gIC8vIHNraXAgcmUtcmVuZGVyaW5nIHRoZSBlcnJvciBwYWdlIGNsaWVudC1zaWRlIGFzIGRhdGEtZmV0Y2hpbmcgb3BlcmF0aW9uc1xuICAvLyB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIGRvbmUgb24gdGhlIHNlcnZlciBhbmQgTkVYVF9EQVRBIGNvbnRhaW5zIHRoZSBjb3JyZWN0XG4gIC8vIGRhdGEgZm9yIHN0cmFpZ2h0LWZvcndhcmQgaHlkcmF0aW9uIG9mIHRoZSBlcnJvciBwYWdlXG4gIGlmIChcbiAgICByZW5kZXJpbmdQcm9wcy5lcnIgJiZcbiAgICAvLyByZW5kZXJpbmdQcm9wcy5Db21wb25lbnQgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIGEgdG9wL21vZHVsZS1sZXZlbCBlcnJvclxuICAgICh0eXBlb2YgcmVuZGVyaW5nUHJvcHMuQ29tcG9uZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgIXJlbmRlcmluZ1Byb3BzLmlzSHlkcmF0ZVBhc3MpXG4gICkge1xuICAgIGF3YWl0IHJlbmRlckVycm9yKHJlbmRlcmluZ1Byb3BzKVxuICAgIHJldHVyblxuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBkb1JlbmRlcihyZW5kZXJpbmdQcm9wcylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3QgcmVuZGVyRXJyID0gZ2V0UHJvcGVyRXJyb3IoZXJyKVxuICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxhdGlvbiBlcnJvcnNcbiAgICBpZiAoKHJlbmRlckVyciBhcyBFcnJvciAmIHsgY2FuY2VsbGVkPzogYm9vbGVhbiB9KS5jYW5jZWxsZWQpIHtcbiAgICAgIHRocm93IHJlbmRlckVyclxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgLy8gRW5zdXJlIHRoaXMgZXJyb3IgaXMgZGlzcGxheWVkIGluIHRoZSBvdmVybGF5IGluIGRldmVsb3BtZW50XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgcmVuZGVyRXJyXG4gICAgICB9KVxuICAgIH1cbiAgICBhd2FpdCByZW5kZXJFcnJvcih7IC4uLnJlbmRlcmluZ1Byb3BzLCBlcnI6IHJlbmRlckVyciB9KVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoeWRyYXRlKG9wdHM/OiB7IGJlZm9yZVJlbmRlcj86ICgpID0+IFByb21pc2U8dm9pZD4gfSkge1xuICBsZXQgaW5pdGlhbEVyciA9IGluaXRpYWxEYXRhLmVyclxuXG4gIHRyeSB7XG4gICAgY29uc3QgYXBwRW50cnlwb2ludCA9IGF3YWl0IHBhZ2VMb2FkZXIucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoJy9fYXBwJylcbiAgICBpZiAoJ2Vycm9yJyBpbiBhcHBFbnRyeXBvaW50KSB7XG4gICAgICB0aHJvdyBhcHBFbnRyeXBvaW50LmVycm9yXG4gICAgfVxuXG4gICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCwgZXhwb3J0czogbW9kIH0gPSBhcHBFbnRyeXBvaW50XG4gICAgQ2FjaGVkQXBwID0gYXBwIGFzIEFwcENvbXBvbmVudFxuICAgIGlmIChtb2QgJiYgbW9kLnJlcG9ydFdlYlZpdGFscykge1xuICAgICAgb25QZXJmRW50cnkgPSAoe1xuICAgICAgICBpZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVudHJ5VHlwZSxcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgYXR0cmlidXRpb24sXG4gICAgICB9OiBhbnkpOiB2b2lkID0+IHtcbiAgICAgICAgLy8gQ29tYmluZXMgdGltZXN0YW1wIHdpdGggcmFuZG9tIG51bWJlciBmb3IgdW5pcXVlIElEXG4gICAgICAgIGNvbnN0IHVuaXF1ZUlEOiBzdHJpbmcgPSBgJHtEYXRlLm5vdygpfS0ke1xuICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICg5ZTEyIC0gMSkpICsgMWUxMlxuICAgICAgICB9YFxuICAgICAgICBsZXQgcGVyZlN0YXJ0RW50cnk6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcGVyZlN0YXJ0RW50cnkgPSBlbnRyaWVzWzBdLnN0YXJ0VGltZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2ViVml0YWxzOiBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICAgICAgICAgIGlkOiBpZCB8fCB1bmlxdWVJRCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lIHx8IHBlcmZTdGFydEVudHJ5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSA9PSBudWxsID8gZHVyYXRpb24gOiB2YWx1ZSxcbiAgICAgICAgICBsYWJlbDpcbiAgICAgICAgICAgIGVudHJ5VHlwZSA9PT0gJ21hcmsnIHx8IGVudHJ5VHlwZSA9PT0gJ21lYXN1cmUnXG4gICAgICAgICAgICAgID8gJ2N1c3RvbSdcbiAgICAgICAgICAgICAgOiAnd2ViLXZpdGFsJyxcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRpb24pIHtcbiAgICAgICAgICB3ZWJWaXRhbHMuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvblxuICAgICAgICB9XG4gICAgICAgIG1vZC5yZXBvcnRXZWJWaXRhbHMod2ViVml0YWxzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhZ2VFbnRyeXBvaW50ID1cbiAgICAgIC8vIFRoZSBkZXYgc2VydmVyIGZhaWxzIHRvIHNlcnZlIHNjcmlwdCBhc3NldHMgd2hlbiB0aGVyZSdzIGEgaHlkcmF0aW9uXG4gICAgICAvLyBlcnJvciwgc28gd2UgbmVlZCB0byBza2lwIHdhaXRpbmcgZm9yIHRoZSBlbnRyeXBvaW50LlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgaW5pdGlhbERhdGEuZXJyXG4gICAgICAgID8geyBlcnJvcjogaW5pdGlhbERhdGEuZXJyIH1cbiAgICAgICAgOiBhd2FpdCBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLndoZW5FbnRyeXBvaW50KGluaXRpYWxEYXRhLnBhZ2UpXG4gICAgaWYgKCdlcnJvcicgaW4gcGFnZUVudHJ5cG9pbnQpIHtcbiAgICAgIHRocm93IHBhZ2VFbnRyeXBvaW50LmVycm9yXG4gICAgfVxuICAgIENhY2hlZENvbXBvbmVudCA9IHBhZ2VFbnRyeXBvaW50LmNvbXBvbmVudFxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPVxuICAgICAgICByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKSBhcyB0eXBlb2YgaW1wb3J0KCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKVxuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ2FjaGVkQ29tcG9uZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke2luaXRpYWxEYXRhLnBhZ2V9XCJgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbiAgICBpbml0aWFsRXJyID0gZ2V0UHJvcGVyRXJyb3IoZXJyb3IpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBjb25zdCBnZXRTZXJ2ZXJFcnJvciA9IChcbiAgICAgIHJlcXVpcmUoJy4uL3NlcnZlci9kZXYvbm9kZS1zdGFjay1mcmFtZXMnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9zZXJ2ZXIvZGV2L25vZGUtc3RhY2stZnJhbWVzJylcbiAgICApLmdldFNlcnZlckVycm9yXG4gICAgLy8gU2VydmVyLXNpZGUgcnVudGltZSBlcnJvcnMgbmVlZCB0byBiZSByZS10aHJvd24gb24gdGhlIGNsaWVudC1zaWRlIHNvXG4gICAgLy8gdGhhdCB0aGUgb3ZlcmxheSBpcyByZW5kZXJlZC5cbiAgICBpZiAoaW5pdGlhbEVycikge1xuICAgICAgaWYgKGluaXRpYWxFcnIgPT09IGluaXRpYWxEYXRhLmVycikge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBsZXQgZXJyb3JcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgZXJyb3Igb2JqZWN0LiBXZSBgdGhyb3dgIGl0IGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAgICAgLy8gd2lsbCBzZXQgdGhlIGBzdGFja2Agd2hlbiB0aHJvd24sIGFuZCB3ZSB3YW50IHRvIGVuc3VyZSBvdXJzIGlzXG4gICAgICAgICAgICAvLyBub3Qgb3ZlcnJpZGRlbiB3aGVuIHdlIHJlLXRocm93IGl0IGJlbG93LlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGluaXRpYWxFcnIhLm1lc3NhZ2UpXG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3IgPSBlIGFzIEVycm9yXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IubmFtZSA9IGluaXRpYWxFcnIhLm5hbWVcbiAgICAgICAgICBlcnJvci5zdGFjayA9IGluaXRpYWxFcnIhLnN0YWNrXG4gICAgICAgICAgY29uc3QgZXJyU291cmNlID0gaW5pdGlhbEVyci5zb3VyY2UhXG5cbiAgICAgICAgICAvLyBJbiBkZXZlbG9wbWVudCwgZXJyb3IgdGhlIG5hdmlnYXRpb24gQVBJIHVzYWdlIGluIHJ1bnRpbWUsXG4gICAgICAgICAgLy8gc2luY2UgaXQncyBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIHBhZ2VzIHJvdXRlciBhcyBpdCBkb2Vzbid0IGNvbnRhaW4gZXJyb3IgYm91bmRhcnkgbGlrZSBhcHAgcm91dGVyLlxuICAgICAgICAgIGlmIChpc05leHRSb3V0ZXJFcnJvcihpbml0aWFsRXJyKSkge1xuICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9XG4gICAgICAgICAgICAgICdOZXh0LmpzIG5hdmlnYXRpb24gQVBJIGlzIG5vdCBhbGxvd2VkIHRvIGJlIHVzZWQgaW4gUGFnZXMgUm91dGVyLidcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBnZXRTZXJ2ZXJFcnJvcihlcnJvciwgZXJyU291cmNlKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgLy8gV2UgcmVwbGFjZWQgdGhlIHNlcnZlci1zaWRlIGVycm9yIHdpdGggYSBjbGllbnQtc2lkZSBlcnJvciwgYW5kIHNob3VsZFxuICAgICAgLy8gbm8gbG9uZ2VyIHJld3JpdGUgdGhlIHN0YWNrIHRyYWNlIHRvIGEgTm9kZSBlcnJvci5cbiAgICAgIGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aHJvdyBpbml0aWFsRXJyXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKSB7XG4gICAgYXdhaXQgd2luZG93Ll9fTkVYVF9QUkVMT0FEUkVBRFkoaW5pdGlhbERhdGEuZHluYW1pY0lkcylcbiAgfVxuXG4gIHJvdXRlciA9IGNyZWF0ZVJvdXRlcihpbml0aWFsRGF0YS5wYWdlLCBpbml0aWFsRGF0YS5xdWVyeSwgYXNQYXRoLCB7XG4gICAgaW5pdGlhbFByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICBwYWdlTG9hZGVyLFxuICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgIHdyYXBBcHAsXG4gICAgZXJyOiBpbml0aWFsRXJyLFxuICAgIGlzRmFsbGJhY2s6IEJvb2xlYW4oaW5pdGlhbERhdGEuaXNGYWxsYmFjayksXG4gICAgc3Vic2NyaXB0aW9uOiAoaW5mbywgQXBwLCBzY3JvbGwpID0+XG4gICAgICByZW5kZXIoXG4gICAgICAgIE9iamVjdC5hc3NpZ248XG4gICAgICAgICAge30sXG4gICAgICAgICAgT21pdDxSZW5kZXJSb3V0ZUluZm8sICdBcHAnIHwgJ3Njcm9sbCc+LFxuICAgICAgICAgIFBpY2s8UmVuZGVyUm91dGVJbmZvLCAnQXBwJyB8ICdzY3JvbGwnPlxuICAgICAgICA+KHt9LCBpbmZvLCB7XG4gICAgICAgICAgQXBwLFxuICAgICAgICAgIHNjcm9sbCxcbiAgICAgICAgfSkgYXMgUmVuZGVyUm91dGVJbmZvXG4gICAgICApLFxuICAgIGxvY2FsZTogaW5pdGlhbERhdGEubG9jYWxlLFxuICAgIGxvY2FsZXM6IGluaXRpYWxEYXRhLmxvY2FsZXMsXG4gICAgZGVmYXVsdExvY2FsZSxcbiAgICBkb21haW5Mb2NhbGVzOiBpbml0aWFsRGF0YS5kb21haW5Mb2NhbGVzLFxuICAgIGlzUHJldmlldzogaW5pdGlhbERhdGEuaXNQcmV2aWV3LFxuICB9KVxuXG4gIGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSA9IGF3YWl0IHJvdXRlci5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZVxuXG4gIGNvbnN0IHJlbmRlckN0eDogUmVuZGVyUm91dGVJbmZvID0ge1xuICAgIEFwcDogQ2FjaGVkQXBwLFxuICAgIGluaXRpYWw6IHRydWUsXG4gICAgQ29tcG9uZW50OiBDYWNoZWRDb21wb25lbnQsXG4gICAgcHJvcHM6IGluaXRpYWxEYXRhLnByb3BzLFxuICAgIGVycjogaW5pdGlhbEVycixcbiAgICBpc0h5ZHJhdGVQYXNzOiB0cnVlLFxuICB9XG5cbiAgaWYgKG9wdHM/LmJlZm9yZVJlbmRlcikge1xuICAgIGF3YWl0IG9wdHMuYmVmb3JlUmVuZGVyKClcbiAgfVxuXG4gIHJlbmRlcihyZW5kZXJDdHgpXG59XG4iXSwibmFtZXMiOlsiZW1pdHRlciIsImh5ZHJhdGUiLCJpbml0aWFsaXplIiwicm91dGVyIiwidmVyc2lvbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVkVSU0lPTiIsIm1pdHQiLCJsb29zZVRvQXJyYXkiLCJpbnB1dCIsInNsaWNlIiwiY2FsbCIsImluaXRpYWxEYXRhIiwiZGVmYXVsdExvY2FsZSIsInVuZGVmaW5lZCIsImFzUGF0aCIsInBhZ2VMb2FkZXIiLCJhcHBFbGVtZW50IiwiaGVhZE1hbmFnZXIiLCJpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUiLCJsYXN0QXBwUHJvcHMiLCJsYXN0UmVuZGVyUmVqZWN0IiwiZGV2Q2xpZW50IiwiQ2FjaGVkQXBwIiwib25QZXJmRW50cnkiLCJDYWNoZWRDb21wb25lbnQiLCJDb250YWluZXIiLCJSZWFjdCIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZENhdGNoIiwiY29tcG9uZW50RXJyIiwiaW5mbyIsInByb3BzIiwiZm4iLCJjb21wb25lbnREaWRNb3VudCIsInNjcm9sbFRvSGFzaCIsImlzU3NyIiwiaXNGYWxsYmFjayIsIm5leHRFeHBvcnQiLCJpc0R5bmFtaWNSb3V0ZSIsInBhdGhuYW1lIiwibG9jYXRpb24iLCJzZWFyY2giLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwiX19OX1NTRyIsInJlcGxhY2UiLCJTdHJpbmciLCJhc3NpZ24iLCJ1cmxRdWVyeVRvU2VhcmNoUGFyYW1zIiwicXVlcnkiLCJVUkxTZWFyY2hQYXJhbXMiLCJfaCIsInNoYWxsb3ciLCJjYXRjaCIsImVyciIsImNhbmNlbGxlZCIsImNvbXBvbmVudERpZFVwZGF0ZSIsImhhc2giLCJzdWJzdHJpbmciLCJlbCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJzZXRUaW1lb3V0Iiwic2Nyb2xsSW50b1ZpZXciLCJyZW5kZXIiLCJOT0RFX0VOViIsImNoaWxkcmVuIiwiUGFnZXNEZXZPdmVybGF5QnJpZGdlIiwicmVxdWlyZSIsIm9wdHMiLCJ0cmFjZXIiLCJvblNwYW5FbmQiLCJkZWZhdWx0IiwiSlNPTiIsInBhcnNlIiwidGV4dENvbnRlbnQiLCJ3aW5kb3ciLCJfX05FWFRfREFUQV9fIiwicHJlZml4IiwiYXNzZXRQcmVmaXgiLCJzZWxmIiwiX19uZXh0X3NldF9wdWJsaWNfcGF0aF9fIiwiZ2V0VVJMIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwicGFyc2VSZWxhdGl2ZVVybCIsImZvcm1hdFVybCIsImxvY2FsZXMiLCJwYXJzZWRBcyIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImxvY2FsZSIsImRldGVjdGVkRG9tYWluIiwiX19ORVhUX0kxOE5fRE9NQUlOUyIsImhvc3RuYW1lIiwic2NyaXB0TG9hZGVyIiwiaW5pdFNjcmlwdExvYWRlciIsIlBhZ2VMb2FkZXIiLCJidWlsZElkIiwicmVnaXN0ZXIiLCJyIiwiZiIsInJvdXRlTG9hZGVyIiwib25FbnRyeXBvaW50IiwiX19ORVhUX1AiLCJtYXAiLCJwIiwicHVzaCIsImluaXRIZWFkTWFuYWdlciIsImdldElzU3NyIiwicmVuZGVyQXBwIiwiQXBwIiwiYXBwUHJvcHMiLCJBcHBDb250YWluZXIiLCJhZGFwdGVkRm9yQXBwUm91dGVyIiwidXNlTWVtbyIsImFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2UiLCJlcnJvciIsInJlbmRlckVycm9yIiwiY29uc29sZSIsIkFwcFJvdXRlckNvbnRleHQiLCJQcm92aWRlciIsInZhbHVlIiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsImFkYXB0Rm9yU2VhcmNoUGFyYW1zIiwiUGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyIiwiaXNBdXRvRXhwb3J0IiwiYXV0b0V4cG9ydCIsIlBhdGhQYXJhbXNDb250ZXh0IiwiYWRhcHRGb3JQYXRoUGFyYW1zIiwiUm91dGVyQ29udGV4dCIsIm1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsIkltYWdlQ29uZmlnQ29udGV4dCIsIl9fTkVYVF9JTUFHRV9PUFRTIiwid3JhcEFwcCIsIndyYXBwZWRBcHBQcm9wcyIsInJlbmRlckVycm9yUHJvcHMiLCJvblVucmVjb3ZlcmFibGVFcnJvciIsImRvUmVuZGVyIiwic3R5bGVTaGVldHMiLCJsb2FkUGFnZSIsInRoZW4iLCJwYWdlIiwiRXJyb3JDb21wb25lbnQiLCJlcnJvck1vZHVsZSIsImFwcE1vZHVsZSIsIm0iLCJBcHBUcmVlIiwiYXBwQ3R4IiwiY3R4IiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiaW5pdFByb3BzIiwiSGVhZCIsImNhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwicGVyZm9ybWFuY2VNYXJrcyIsIm5hdmlnYXRpb25TdGFydCIsImJlZm9yZVJlbmRlciIsImFmdGVyUmVuZGVyIiwiYWZ0ZXJIeWRyYXRlIiwicm91dGVDaGFuZ2UiLCJwZXJmb3JtYW5jZU1lYXN1cmVzIiwiaHlkcmF0aW9uIiwiYmVmb3JlSHlkcmF0aW9uIiwicm91dGVDaGFuZ2VUb1JlbmRlciIsInJlYWN0Um9vdCIsInNob3VsZEh5ZHJhdGUiLCJjbGVhck1hcmtzIiwiZm9yRWFjaCIsIm1hcmsiLCJwZXJmb3JtYW5jZSIsIm1hcmtIeWRyYXRlQ29tcGxldGUiLCJTVCIsImhhc0JlZm9yZVJlbmRlck1hcmsiLCJnZXRFbnRyaWVzQnlOYW1lIiwibGVuZ3RoIiwiYmVmb3JlSHlkcmF0aW9uTWVhc3VyZSIsIm1lYXN1cmUiLCJoeWRyYXRpb25NZWFzdXJlIiwic3RhcnRTcGFuIiwic3RhcnRUaW1lIiwidGltZU9yaWdpbiIsImF0dHJpYnV0ZXMiLCJlbmQiLCJkdXJhdGlvbiIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIm5hdlN0YXJ0RW50cmllcyIsIm5hbWUiLCJjbGVhck1lYXN1cmVzIiwicmVuZGVyUmVhY3RFbGVtZW50IiwiZG9tRWwiLCJyZWFjdEVsIiwiUmVhY3RET00iLCJoeWRyYXRlUm9vdCIsIm9uUmVjb3ZlcmFibGVFcnJvciIsInN0YXJ0VHJhbnNpdGlvbiIsIlJvb3QiLCJjYWxsYmFja3MiLCJfX05FWFRfVEVTVF9NT0RFIiwidXNlRWZmZWN0IiwiX19ORVhUX0hZRFJBVEVEIiwiX19ORVhUX0hZRFJBVEVEX0FUIiwibm93IiwiX19ORVhUX0hZRFJBVEVEX0NCIiwiY2FuY2VsZWQiLCJyZXNvbHZlUHJvbWlzZSIsInJlbmRlclByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsIm9uU3RhcnQiLCJjdXJyZW50U3R5bGVUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsImN1cnJlbnRIcmVmcyIsIlNldCIsInRhZyIsImdldEF0dHJpYnV0ZSIsIm5vc2NyaXB0IiwicXVlcnlTZWxlY3RvciIsIm5vbmNlIiwiaHJlZiIsInRleHQiLCJoYXMiLCJzdHlsZVRhZyIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9uSGVhZENvbW1pdCIsIlRVUkJPUEFDSyIsImRlc2lyZWRIcmVmcyIsInMiLCJpZHgiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZWZlcmVuY2VOb2RlIiwidGFyZ2V0VGFnIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwicmVtb3ZlQ2hpbGQiLCJzY3JvbGwiLCJ4IiwieSIsImRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24iLCJzY3JvbGxUbyIsIm9uUm9vdENvbW1pdCIsImVsZW0iLCJQb3J0YWwiLCJ0eXBlIiwiUm91dGVBbm5vdW5jZXIiLCJfX05FWFRfU1RSSUNUX01PREUiLCJTdHJpY3RNb2RlIiwicmVuZGVyaW5nUHJvcHMiLCJpc0h5ZHJhdGVQYXNzIiwicmVuZGVyRXJyIiwiZ2V0UHJvcGVyRXJyb3IiLCJpbml0aWFsRXJyIiwiYXBwRW50cnlwb2ludCIsIndoZW5FbnRyeXBvaW50IiwiY29tcG9uZW50IiwiYXBwIiwiZXhwb3J0cyIsIm1vZCIsInJlcG9ydFdlYlZpdGFscyIsImlkIiwiZW50cnlUeXBlIiwiZW50cmllcyIsImF0dHJpYnV0aW9uIiwidW5pcXVlSUQiLCJEYXRlIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwicGVyZlN0YXJ0RW50cnkiLCJ3ZWJWaXRhbHMiLCJsYWJlbCIsInBhZ2VFbnRyeXBvaW50IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZ2V0U2VydmVyRXJyb3IiLCJtZXNzYWdlIiwiZSIsInN0YWNrIiwiZXJyU291cmNlIiwic291cmNlIiwiaXNOZXh0Um91dGVyRXJyb3IiLCJfX05FWFRfUFJFTE9BRFJFQURZIiwiZHluYW1pY0lkcyIsImNyZWF0ZVJvdXRlciIsImluaXRpYWxQcm9wcyIsIkJvb2xlYW4iLCJzdWJzY3JpcHRpb24iLCJPYmplY3QiLCJkb21haW5Mb2NhbGVzIiwiaXNQcmV2aWV3IiwiX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2UiLCJyZW5kZXJDdHgiLCJpbml0aWFsIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../node_modules/next/dist/client/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/router.js":
/*!*************************************************************!*\
  !*** ../node_modules/next/dist/shared/lib/router/router.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createKey: function() {\n        return createKey;\n    },\n    default: function() {\n        return Router;\n    },\n    matchesMiddleware: function() {\n        return matchesMiddleware;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(pages-dir-browser)/../node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(pages-dir-browser)/../node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"(pages-dir-browser)/../node_modules/next/dist/client/route-loader.js\");\nconst _script = __webpack_require__(/*! ../../../client/script */ \"(pages-dir-browser)/../node_modules/next/dist/client/script.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"(pages-dir-browser)/../node_modules/next/dist/lib/is-error.js\"));\nconst _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nconst _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../mitt */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/mitt.js\"));\nconst _utils = __webpack_require__(/*! ../utils */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/utils.js\");\nconst _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nconst _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nconst _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nconst _formaturl = __webpack_require__(/*! ./utils/format-url */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"(pages-dir-browser)/../node_modules/next/dist/client/detect-domain-locale.js\");\nconst _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nconst _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"(pages-dir-browser)/../node_modules/next/dist/client/add-locale.js\");\nconst _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"(pages-dir-browser)/../node_modules/next/dist/client/remove-locale.js\");\nconst _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"(pages-dir-browser)/../node_modules/next/dist/client/remove-base-path.js\");\nconst _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"(pages-dir-browser)/../node_modules/next/dist/client/add-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"(pages-dir-browser)/../node_modules/next/dist/client/has-base-path.js\");\nconst _resolvehref = __webpack_require__(/*! ../../../client/resolve-href */ \"(pages-dir-browser)/../node_modules/next/dist/client/resolve-href.js\");\nconst _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"(pages-dir-browser)/../node_modules/next/dist/lib/is-api-route.js\");\nconst _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nconst _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nconst _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nconst _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _isbot = __webpack_require__(/*! ./utils/is-bot */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nconst _omit = __webpack_require__(/*! ./utils/omit */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/omit.js\");\nconst _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nconst _disablesmoothscroll = __webpack_require__(/*! ./utils/disable-smooth-scroll */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js\");\nconst _constants = __webpack_require__(/*! ../../../lib/constants */ \"(pages-dir-browser)/../node_modules/next/dist/lib/constants.js\");\nconst _deploymentid = __webpack_require__(/*! ../deployment-id */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/deployment-id.js\");\nlet resolveRewrites;\nif (false) {}\nfunction buildCancellationError() {\n    return Object.assign(Object.defineProperty(new Error('Route Cancelled'), \"__NEXT_ERROR_CODE\", {\n        value: \"E315\",\n        enumerable: false,\n        configurable: true\n    }), {\n        cancelled: true\n    });\n}\nasync function matchesMiddleware(options) {\n    const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());\n    if (!matchers) return false;\n    const { pathname: asPathname } = (0, _parsepath.parsePath)(options.asPath);\n    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n    const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n    const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n    // Check only path match on client. Matching \"has\" should be done on server\n    // where we can access more info such as headers, HttpOnly cookie, etc.\n    return matchers.some((m)=>new RegExp(m.regexp).test(asWithBasePathAndLocale));\n}\nfunction stripOrigin(url) {\n    const origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);\n    const origin = (0, _utils.getLocationOrigin)();\n    const hrefWasAbsolute = resolvedHref.startsWith(origin);\n    const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === '/404' || cleanPathname === '/_error') {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some((page)=>{\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    const nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    const rewriteHeader = response.headers.get('x-nextjs-rewrite');\n    let rewriteTarget = rewriteHeader || response.headers.get('x-nextjs-matched-path');\n    const matchedPath = response.headers.get(_constants.MATCHED_PATH_HEADER);\n    if (matchedPath && !rewriteTarget && !matchedPath.includes('__next_data_catchall') && !matchedPath.includes('/_error') && !matchedPath.includes('/404')) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith('/') || false) {\n            const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig,\n                parseData: true\n            });\n            let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then(([pages, { __rewrites: rewrites }])=>{\n                let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig:  false ? 0 : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) {} else if (!pages.includes(fsPathname)) {\n                    const resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: 'rewrite',\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref\n                };\n            });\n        }\n        const src = (0, _parsepath.parsePath)(source);\n        const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n            ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                nextConfig,\n                parseData: true\n            }),\n            defaultLocale: options.router.defaultLocale,\n            buildId: ''\n        });\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: `${pathname}${src.query}${src.hash}`\n        });\n    }\n    const redirectTarget = response.headers.get('x-nextjs-redirect');\n    if (redirectTarget) {\n        if (redirectTarget.startsWith('/')) {\n            const src = (0, _parsepath.parsePath)(redirectTarget);\n            const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({\n                ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n                    nextConfig,\n                    parseData: true\n                }),\n                defaultLocale: options.router.defaultLocale,\n                buildId: ''\n            });\n            return Promise.resolve({\n                type: 'redirect-internal',\n                newAs: `${pathname}${src.query}${src.hash}`,\n                newUrl: `${pathname}${src.query}${src.hash}`\n            });\n        }\n        return Promise.resolve({\n            type: 'redirect-external',\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: 'next'\n    });\n}\nasync function withMiddlewareEffects(options) {\n    const matches = await matchesMiddleware(options);\n    if (!matches || !options.fetchData) {\n        return null;\n    }\n    const data = await options.fetchData();\n    const effect = await getMiddlewareData(data.dataHref, data.response, options);\n    return {\n        dataHref: data.dataHref,\n        json: data.json,\n        response: data.response,\n        text: data.text,\n        cacheKey: data.cacheKey,\n        effect\n    };\n}\nconst manualScrollRestoration =  false && 0;\nconst SSG_DATA_NOT_FOUND = Symbol('SSG_DATA_NOT_FOUND');\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wont send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: 'same-origin',\n        method: options.method || 'GET',\n        headers: Object.assign({}, options.headers, {\n            'x-nextjs-data': '1'\n        })\n    }).then((response)=>{\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData({ dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache }) {\n    const { href: cacheKey } = new URL(dataHref, window.location.href);\n    const deploymentId = (0, _deploymentid.getDeploymentId)();\n    const getData = (params)=>fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: 'prefetch'\n            } : {}, isPrefetch && hasMiddleware ? {\n                'x-middleware-prefetch': '1'\n            } : {}, deploymentId ? {\n                'x-deployment-id': deploymentId\n            } : {}),\n            method: params?.method ?? 'GET'\n        }).then((response)=>{\n            if (response.ok && params?.method === 'HEAD') {\n                return {\n                    dataHref,\n                    response,\n                    text: '',\n                    json: {},\n                    cacheKey\n                };\n            }\n            return response.text().then((text)=>{\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref,\n                            response,\n                            text,\n                            json: {},\n                            cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        if (tryToParseAsJSON(text)?.notFound) {\n                            return {\n                                dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response,\n                                text,\n                                cacheKey\n                            };\n                        }\n                    }\n                    const error = Object.defineProperty(new Error(`Failed to load static props`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E124\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response,\n                    text,\n                    cacheKey\n                };\n            });\n        }).then((data)=>{\n            if (!persistCache || \"development\" !== 'production' || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        }).catch((err)=>{\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === 'Failed to fetch' || // firefox\n            err.message === 'NetworkError when attempting to fetch resource.' || // safari\n            err.message === 'Load failed') {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then((data)=>{\n            if (data.response.headers.get('x-middleware-cache') !== 'no-cache') {\n                // only update cache if not marked as no-cache\n                inflightCache[cacheKey] = Promise.resolve(data);\n            }\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: 'HEAD'\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation({ url, router }) {\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw Object.defineProperty(new Error(`Invariant: attempted to hard navigate to the same URL ${url} ${location.href}`), \"__NEXT_ERROR_CODE\", {\n            value: \"E282\",\n            enumerable: false,\n            configurable: true\n        });\n    }\n    window.location.href = url;\n}\nconst getCancelledHandler = ({ route, router })=>{\n    let cancelled = false;\n    const cancel = router.clc = ()=>{\n        cancelled = true;\n    };\n    const handleCancelled = ()=>{\n        if (cancelled) {\n            const error = Object.defineProperty(new Error(`Abort fetching component for route: \"${route}\"`), \"__NEXT_ERROR_CODE\", {\n                value: \"E483\",\n                enumerable: false,\n                configurable: true\n            });\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nclass Router {\n    static{\n        this.events = (0, _mitt.default)();\n    }\n    constructor(pathname, query, as, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }){\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = (e)=>{\n            const { isFirstPopStateEvent } = this;\n            this.isFirstPopStateEvent = false;\n            const state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                const { pathname, query } = this;\n                this.changeState('replaceState', (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(pathname),\n                    query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {\n                return;\n            }\n            let forcedScroll;\n            const { url, as, options, key } = state;\n            if (false) {}\n            this._key = key;\n            const { pathname } = (0, _parserelativeurl.parseRelativeUrl)(url);\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (this.isSsr && as === (0, _addbasepath.addBasePath)(this.asPath) && pathname === (0, _addbasepath.addBasePath)(this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (this._bps && !this._bps(state)) {\n                return;\n            }\n            this.change('replaceState', url, as, Object.assign({}, options, {\n                shallow: options.shallow && this._shallow,\n                locale: options.locale || this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== '/_error') {\n            this.components[route] = {\n                Component,\n                initial: true,\n                props: initialProps,\n                err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components['/_app'] = {\n            Component: App,\n            styleSheets: []\n        };\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || '';\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route,\n            pathname,\n            query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith('//')) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                const options = {\n                    locale\n                };\n                const asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale,\n                    asPath\n                }).then((matches)=>{\n                    // if middleware matches we leave resolving to the change function\n                    // as the server needs to resolve for correct priority\n                    ;\n                    options._shouldResolveHref = as !== pathname;\n                    this.changeState('replaceState', matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener('popstate', this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    reload() {\n        window.location.reload();\n    }\n    /**\n   * Go back in history\n   */ back() {\n        window.history.back();\n    }\n    /**\n   * Go forward in history\n   */ forward() {\n        window.history.forward();\n    }\n    /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ push(url, as, options = {}) {\n        if (false) {}\n        ;\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change('pushState', url, as, options);\n    }\n    /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ replace(url, as, options = {}) {\n        ;\n        ({ url, as } = prepareUrlAs(this, url, as));\n        return this.change('replaceState', url, as, options);\n    }\n    async _bfl(as, resolvedAs, locale, skipNavigate) {\n        if (true) {\n            if (!this._bfl_s && !this._bfl_d) {\n                const { BloomFilter } = __webpack_require__(/*! ../../lib/bloom-filter */ \"(pages-dir-browser)/../node_modules/next/dist/shared/lib/bloom-filter.js\");\n                let staticFilterData;\n                let dynamicFilterData;\n                try {\n                    ;\n                    ({ __routerFilterStatic: staticFilterData, __routerFilterDynamic: dynamicFilterData } = await (0, _routeloader.getClientBuildManifest)());\n                } catch (err) {\n                    // failed to load build manifest hard navigate\n                    // to be safe\n                    console.error(err);\n                    if (skipNavigate) {\n                        return true;\n                    }\n                    handleHardNavigation({\n                        url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                const routerFilterSValue = {\"numItems\":20,\"errorRate\":0.0001,\"numBits\":384,\"numHashes\":14,\"bitArray\":[1,1,0,1,0,0,1,0,1,1,1,0,0,1,0,1,0,1,1,1,0,1,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,0,1,0,0,1,0,1,0,1,1,1,1,1,1,1,0,0,0,0,1,0,1,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,0,0,1,0,0,1,0,0,1,1,1,0,1,1,1,0,0,0,1,0,1,0,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,1,0,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,0,0,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,0,0,1,1,0,1,1,1,0,0,0,1,1,0,0,1,0,1,1,1,0,1,0,0,1,1,1,1,1,0,1,1,1,0,1,0,1,1,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,0,1,1,0,0,0,1,1,1,0,1,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,1,0,1,0,1,1,1,0,0,1,1,0,1,1,0,0,1,1,0,0,0,1,1,0,1,0,1,0,0,1,1,1,0,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,0,1,0,0,0,1,0,1,1,0,0,0,0,0,1,1,0,1,0,0,1,1,0,1,1,1,1,1,0,1,1,0,1,1,1,0,0,1,1,1,0,0,1,1,0]};\n                if (!staticFilterData && routerFilterSValue) {\n                    staticFilterData = routerFilterSValue ? routerFilterSValue : undefined;\n                }\n                const routerFilterDValue = {\"numItems\":4,\"errorRate\":0.0001,\"numBits\":77,\"numHashes\":14,\"bitArray\":[1,0,1,0,1,0,0,1,1,0,1,0,0,0,0,0,1,1,0,0,1,1,1,1,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,1,1,0,0,1,1,0,1,1,1,0,1,1,1,1,1,1,0,0,1,0,1,0,1,0,0,1,0,0,0,1,0,1,1,1,0,1,0]};\n                if (!dynamicFilterData && routerFilterDValue) {\n                    dynamicFilterData = routerFilterDValue ? routerFilterDValue : undefined;\n                }\n                if (staticFilterData?.numHashes) {\n                    this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                    this._bfl_s.import(staticFilterData);\n                }\n                if (dynamicFilterData?.numHashes) {\n                    this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                    this._bfl_d.import(dynamicFilterData);\n                }\n            }\n            let matchesBflStatic = false;\n            let matchesBflDynamic = false;\n            const pathsToCheck = [\n                {\n                    as\n                },\n                {\n                    as: resolvedAs\n                }\n            ];\n            for (const { as: curAs, allowMatchCurrent } of pathsToCheck){\n                if (curAs) {\n                    const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, 'http://n').pathname);\n                    const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));\n                    if (allowMatchCurrent || asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, 'http://n').pathname)) {\n                        matchesBflStatic = matchesBflStatic || !!this._bfl_s?.contains(asNoSlash) || !!this._bfl_s?.contains(asNoSlashLocale);\n                        for (const normalizedAS of [\n                            asNoSlash,\n                            asNoSlashLocale\n                        ]){\n                            // if any sub-path of as matches a dynamic filter path\n                            // it should be hard navigated\n                            const curAsParts = normalizedAS.split('/');\n                            for(let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                const currentPart = curAsParts.slice(0, i).join('/');\n                                if (currentPart && this._bfl_d?.contains(currentPart)) {\n                                    matchesBflDynamic = true;\n                                    break;\n                                }\n                            }\n                        }\n                        // if the client router filter is matched then we trigger\n                        // a hard navigation\n                        if (matchesBflStatic || matchesBflDynamic) {\n                            if (skipNavigate) {\n                                return true;\n                            }\n                            handleHardNavigation({\n                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),\n                                router: this\n                            });\n                            return new Promise(()=>{});\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    async change(method, url, as, options, forcedScroll) {\n        if (!(0, _islocalurl.isLocalURL)(url)) {\n            handleHardNavigation({\n                url,\n                router: this\n            });\n            return false;\n        }\n        // WARNING: `_h` is an internal option for handing Next.js client-side\n        // hydration. Your app should _never_ use this property. It may change at\n        // any time without notice.\n        const isQueryUpdating = options._h === 1;\n        if (!isQueryUpdating && !options.shallow) {\n            await this._bfl(as, undefined, options.locale);\n        }\n        let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n        const nextState = {\n            ...this.state\n        };\n        // for static pages with query params in the URL we delay\n        // marking the router ready until after the query is updated\n        // or a navigation has occurred\n        const readyStateChange = this.isReady !== true;\n        this.isReady = true;\n        const isSsr = this.isSsr;\n        if (!isQueryUpdating) {\n            this.isSsr = false;\n        }\n        // if a route transition is already in progress before\n        // the query updating is triggered ignore query updating\n        if (isQueryUpdating && this.clc) {\n            return false;\n        }\n        const prevLocale = nextState.locale;\n        if (false) {}\n        // marking route changes as a navigation start entry\n        if (_utils.ST) {\n            performance.mark('routeChange');\n        }\n        const { shallow = false, scroll = true } = options;\n        const routeProps = {\n            shallow\n        };\n        if (this._inFlightRoute && this.clc) {\n            if (!isSsr) {\n                Router.events.emit('routeChangeError', buildCancellationError(), this._inFlightRoute, routeProps);\n            }\n            this.clc();\n            this.clc = null;\n        }\n        as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));\n        const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n        this._inFlightRoute = as;\n        const localeChange = prevLocale !== nextState.locale;\n        // If the url change is only related to a hash change\n        // We should not proceed. We should only change the state.\n        if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {\n            nextState.asPath = cleanedAs;\n            Router.events.emit('hashChangeStart', as, routeProps);\n            // TODO: do we need the resolved href when only a hash change?\n            this.changeState(method, url, as, {\n                ...options,\n                scroll: false\n            });\n            if (scroll) {\n                this.scrollToHash(cleanedAs);\n            }\n            try {\n                await this.set(nextState, this.components[nextState.route], null);\n            } catch (err) {\n                if ((0, _iserror.default)(err) && err.cancelled) {\n                    Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                }\n                throw err;\n            }\n            Router.events.emit('hashChangeComplete', as, routeProps);\n            return true;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        let { pathname, query } = parsed;\n        // The build manifest needs to be loaded before auto-static dynamic pages\n        // get their query parameters to allow ensuring they can be parsed properly\n        // when rewritten to\n        let pages, rewrites;\n        try {\n            ;\n            [pages, { __rewrites: rewrites }] = await Promise.all([\n                this.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)(),\n                this.pageLoader.getMiddleware()\n            ]);\n        } catch (err) {\n            // If we fail to resolve the page list or client-build manifest, we must\n            // do a server-side transition:\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        // If asked to change the current URL we should reload the current page\n        // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n        // We also need to set the method = replaceState always\n        // as this should not go into the history (That's how browsers work)\n        // We should compare the new asPath to the current asPath, not the url\n        if (!this.urlIsNew(cleanedAs) && !localeChange) {\n            method = 'replaceState';\n        }\n        // we need to resolve the as value using rewrites for dynamic SSG\n        // pages to allow building the data URL correctly\n        let resolvedAs = as;\n        // url and as should always be prefixed with basePath by this\n        // point by either next/link or router.push/replace so strip the\n        // basePath from the pathname to match the pages dir 1-to-1\n        pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n        let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        const parsedAsPathname = as.startsWith('/') && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n        // if we detected the path as app route during prefetching\n        // trigger hard navigation\n        if (this.components[pathname]?.__appRouter) {\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return new Promise(()=>{});\n        }\n        const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n        // we don't attempt resolve asPath when we need to execute\n        // middleware as the resolving will occur server-side\n        const isMiddlewareMatch = !options.shallow && await matchesMiddleware({\n            asPath: as,\n            locale: nextState.locale,\n            router: this\n        });\n        if (isQueryUpdating && isMiddlewareMatch) {\n            shouldResolveHref = false;\n        }\n        if (shouldResolveHref && pathname !== '/_error') {\n            ;\n            options._shouldResolveHref = true;\n            if (false) {} else {\n                parsed.pathname = resolveDynamicRoute(pathname, pages);\n                if (parsed.pathname !== pathname) {\n                    pathname = parsed.pathname;\n                    parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                    if (!isMiddlewareMatch) {\n                        url = (0, _formaturl.formatWithValidation)(parsed);\n                    }\n                }\n            }\n        }\n        if (!(0, _islocalurl.isLocalURL)(as)) {\n            if (true) {\n                throw Object.defineProperty(new Error(`Invalid href: \"${url}\" and as: \"${as}\", received relative href and external as` + `\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as`), \"__NEXT_ERROR_CODE\", {\n                    value: \"E380\",\n                    enumerable: false,\n                    configurable: true\n                });\n            }\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            return false;\n        }\n        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n        route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        let routeMatch = false;\n        if ((0, _isdynamic.isDynamicRoute)(route)) {\n            const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n            const asPathname = parsedAs.pathname;\n            const routeRegex = (0, _routeregex.getRouteRegex)(route);\n            routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n            const shouldInterpolate = route === asPathname;\n            const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n            if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                const missingParams = Object.keys(routeRegex.groups).filter((param)=>!query[param] && !routeRegex.groups[param].optional);\n                if (missingParams.length > 0 && !isMiddlewareMatch) {\n                    if (true) {\n                        console.warn(`${shouldInterpolate ? `Interpolating href` : `Mismatching \\`as\\` and \\`href\\``} failed to manually provide ` + `the params: ${missingParams.join(', ')} in the \\`href\\`'s \\`query\\``);\n                    }\n                    throw Object.defineProperty(new Error((shouldInterpolate ? `The provided \\`href\\` (${url}) value is missing query values (${missingParams.join(', ')}) to be interpolated properly. ` : `The provided \\`as\\` value (${asPathname}) is incompatible with the \\`href\\` value (${route}). `) + `Read more: https://nextjs.org/docs/messages/${shouldInterpolate ? 'href-interpolation-failed' : 'incompatible-href-as'}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E344\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            } else if (shouldInterpolate) {\n                as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {\n                    pathname: interpolatedAs.result,\n                    query: (0, _omit.omit)(query, interpolatedAs.params)\n                }));\n            } else {\n                // Merge params into `query`, overwriting any specified in search\n                Object.assign(query, routeMatch);\n            }\n        }\n        if (!isQueryUpdating) {\n            Router.events.emit('routeChangeStart', as, routeProps);\n        }\n        const isErrorRoute = this.pathname === '/404' || this.pathname === '/_error';\n        try {\n            let routeInfo = await this.getRouteInfo({\n                route,\n                pathname,\n                query,\n                as,\n                resolvedAs,\n                routeProps,\n                locale: nextState.locale,\n                isPreview: nextState.isPreview,\n                hasMiddleware: isMiddlewareMatch,\n                unstable_skipClientCache: options.unstable_skipClientCache,\n                isQueryUpdating: isQueryUpdating && !this.isFallback,\n                isMiddlewareRewrite\n            });\n            if (!isQueryUpdating && !options.shallow) {\n                await this._bfl(as, 'resolvedAs' in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale);\n            }\n            if ('route' in routeInfo && isMiddlewareMatch) {\n                pathname = routeInfo.route || route;\n                route = pathname;\n                if (!routeProps.shallow) {\n                    query = Object.assign({}, routeInfo.query || {}, query);\n                }\n                const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                if (routeMatch && pathname !== cleanedParsedPathname) {\n                    Object.keys(routeMatch).forEach((key)=>{\n                        if (routeMatch && query[key] === routeMatch[key]) {\n                            delete query[key];\n                        }\n                    });\n                }\n                if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                    const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                    let rewriteAs = prefixedAs;\n                    if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                        rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                    }\n                    if (false) {}\n                    const routeRegex = (0, _routeregex.getRouteRegex)(pathname);\n                    const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);\n                    if (curRouteMatch) {\n                        Object.assign(query, curRouteMatch);\n                    }\n                }\n            }\n            // If the routeInfo brings a redirect we simply apply it.\n            if ('type' in routeInfo) {\n                if (routeInfo.type === 'redirect-internal') {\n                    return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);\n                } else {\n                    handleHardNavigation({\n                        url: routeInfo.destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n            }\n            const component = routeInfo.Component;\n            if (component && component.unstable_scriptLoader) {\n                const scripts = [].concat(component.unstable_scriptLoader());\n                scripts.forEach((script)=>{\n                    (0, _script.handleClientScriptLoad)(script.props);\n                });\n            }\n            // handle redirect on client-transition\n            if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {\n                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                    // Use the destination from redirect without adding locale\n                    options.locale = false;\n                    const destination = routeInfo.props.pageProps.__N_REDIRECT;\n                    // check if destination is internal (resolves to a page) and attempt\n                    // client-navigation if it is falling back to hard navigation if\n                    // it's not\n                    if (destination.startsWith('/') && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                        const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                        const { url: newUrl, as: newAs } = prepareUrlAs(this, destination, destination);\n                        return this.change(method, newUrl, newAs, options);\n                    }\n                    handleHardNavigation({\n                        url: destination,\n                        router: this\n                    });\n                    return new Promise(()=>{});\n                }\n                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                // handle SSG data 404\n                if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {\n                    let notFoundRoute;\n                    try {\n                        await this.fetchComponent('/404');\n                        notFoundRoute = '/404';\n                    } catch (_) {\n                        notFoundRoute = '/_error';\n                    }\n                    routeInfo = await this.getRouteInfo({\n                        route: notFoundRoute,\n                        pathname: notFoundRoute,\n                        query,\n                        as,\n                        resolvedAs,\n                        routeProps: {\n                            shallow: false\n                        },\n                        locale: nextState.locale,\n                        isPreview: nextState.isPreview,\n                        isNotFound: true\n                    });\n                    if ('type' in routeInfo) {\n                        throw Object.defineProperty(new Error(`Unexpected middleware effect on /404`), \"__NEXT_ERROR_CODE\", {\n                            value: \"E158\",\n                            enumerable: false,\n                            configurable: true\n                        });\n                    }\n                }\n            }\n            if (isQueryUpdating && this.pathname === '/_error' && self.__NEXT_DATA__.props?.pageProps?.statusCode === 500 && routeInfo.props?.pageProps) {\n                // ensure statusCode is still correct for static 500 page\n                // when updating query information\n                routeInfo.props.pageProps.statusCode = 500;\n            }\n            // shallow routing is only allowed for same page URL changes.\n            const isValidShallowRoute = options.shallow && nextState.route === (routeInfo.route ?? route);\n            const shouldScroll = options.scroll ?? (!isQueryUpdating && !isValidShallowRoute);\n            const resetScroll = shouldScroll ? {\n                x: 0,\n                y: 0\n            } : null;\n            const upcomingScrollState = forcedScroll ?? resetScroll;\n            // the new state that the router gonna set\n            const upcomingRouterState = {\n                ...nextState,\n                route,\n                pathname,\n                query,\n                asPath: cleanedAs,\n                isFallback: false\n            };\n            // When the page being rendered is the 404 page, we should only update the\n            // query parameters. Route changes here might add the basePath when it\n            // wasn't originally present. This is also why this block is before the\n            // below `changeState` call which updates the browser's history (changing\n            // the URL).\n            if (isQueryUpdating && isErrorRoute) {\n                routeInfo = await this.getRouteInfo({\n                    route: this.pathname,\n                    pathname: this.pathname,\n                    query,\n                    as,\n                    resolvedAs,\n                    routeProps: {\n                        shallow: false\n                    },\n                    locale: nextState.locale,\n                    isPreview: nextState.isPreview,\n                    isQueryUpdating: isQueryUpdating && !this.isFallback\n                });\n                if ('type' in routeInfo) {\n                    throw Object.defineProperty(new Error(`Unexpected middleware effect on ${this.pathname}`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E225\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n                if (this.pathname === '/_error' && self.__NEXT_DATA__.props?.pageProps?.statusCode === 500 && routeInfo.props?.pageProps) {\n                    // ensure statusCode is still correct for static 500 page\n                    // when updating query information\n                    routeInfo.props.pageProps.statusCode = 500;\n                }\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (err) {\n                    if ((0, _iserror.default)(err) && err.cancelled) {\n                        Router.events.emit('routeChangeError', err, cleanedAs, routeProps);\n                    }\n                    throw err;\n                }\n                return true;\n            }\n            Router.events.emit('beforeHistoryChange', as, routeProps);\n            this.changeState(method, url, as, options);\n            // for query updates we can skip it if the state is unchanged and we don't\n            // need to scroll\n            // https://github.com/vercel/next.js/issues/37139\n            const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);\n            if (!canSkipUpdating) {\n                try {\n                    await this.set(upcomingRouterState, routeInfo, upcomingScrollState);\n                } catch (e) {\n                    if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                    else throw e;\n                }\n                if (routeInfo.error) {\n                    if (!isQueryUpdating) {\n                        Router.events.emit('routeChangeError', routeInfo.error, cleanedAs, routeProps);\n                    }\n                    throw routeInfo.error;\n                }\n                if (false) {}\n                if (!isQueryUpdating) {\n                    Router.events.emit('routeChangeComplete', as, routeProps);\n                }\n                // A hash mark # is the optional last part of a URL\n                const hashRegex = /#.+$/;\n                if (shouldScroll && hashRegex.test(as)) {\n                    this.scrollToHash(as);\n                }\n            }\n            return true;\n        } catch (err) {\n            if ((0, _iserror.default)(err) && err.cancelled) {\n                return false;\n            }\n            throw err;\n        }\n    }\n    changeState(method, url, as, options = {}) {\n        if (true) {\n            if (typeof window.history === 'undefined') {\n                console.error(`Warning: window.history is not available.`);\n                return;\n            }\n            if (typeof window.history[method] === 'undefined') {\n                console.error(`Warning: window.history.${method} is not available`);\n                return;\n            }\n        }\n        if (method !== 'pushState' || (0, _utils.getURL)() !== as) {\n            this._shallow = options.shallow;\n            window.history[method]({\n                url,\n                as,\n                options,\n                __N: true,\n                key: this._key = method !== 'pushState' ? this._key : createKey()\n            }, // Passing the empty string here should be safe against future changes to the method.\n            // https://developer.mozilla.org/docs/Web/API/History/replaceState\n            '', as);\n        }\n    }\n    async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n        if (err.cancelled) {\n            // bubble up cancellation errors\n            throw err;\n        }\n        if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n            Router.events.emit('routeChangeError', err, as, routeProps);\n            // If we can't load the page it could be one of following reasons\n            //  1. Page doesn't exists\n            //  2. Page does exist in a different zone\n            //  3. Internal error while loading the page\n            // So, doing a hard reload is the proper way to deal with this.\n            handleHardNavigation({\n                url: as,\n                router: this\n            });\n            // Changing the URL doesn't block executing the current code path.\n            // So let's throw a cancellation error stop the routing logic.\n            throw buildCancellationError();\n        }\n        console.error(err);\n        try {\n            let props;\n            const { page: Component, styleSheets } = await this.fetchComponent('/_error');\n            const routeInfo = {\n                props,\n                Component,\n                styleSheets,\n                err,\n                error: err\n            };\n            if (!routeInfo.props) {\n                try {\n                    routeInfo.props = await this.getInitialProps(Component, {\n                        err,\n                        pathname,\n                        query\n                    });\n                } catch (gipErr) {\n                    console.error('Error in error page `getInitialProps`: ', gipErr);\n                    routeInfo.props = {};\n                }\n            }\n            return routeInfo;\n        } catch (routeInfoErr) {\n            return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : Object.defineProperty(new Error(routeInfoErr + ''), \"__NEXT_ERROR_CODE\", {\n                value: \"E394\",\n                enumerable: false,\n                configurable: true\n            }), pathname, query, as, routeProps, true);\n        }\n    }\n    async getRouteInfo({ route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound }) {\n        /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ let route = requestedRoute;\n        try {\n            let existingInfo = this.components[route];\n            if (routeProps.shallow && existingInfo && this.route === route) {\n                return existingInfo;\n            }\n            const handleCancelled = getCancelledHandler({\n                route,\n                router: this\n            });\n            if (hasMiddleware) {\n                existingInfo = undefined;\n            }\n            let cachedRouteInfo = existingInfo && !('initial' in existingInfo) && \"development\" !== 'development' ? 0 : undefined;\n            const isBackground = isQueryUpdating;\n            const fetchNextDataParams = {\n                dataHref: this.pageLoader.getDataHref({\n                    href: (0, _formaturl.formatWithValidation)({\n                        pathname,\n                        query\n                    }),\n                    skipInterpolation: true,\n                    asPath: isNotFound ? '/404' : resolvedAs,\n                    locale\n                }),\n                hasMiddleware: true,\n                isServerRender: this.isSsr,\n                parseJSON: true,\n                inflightCache: isBackground ? this.sbc : this.sdc,\n                persistCache: !isPreview,\n                isPrefetch: false,\n                unstable_skipClientCache,\n                isBackground\n            };\n            let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({\n                fetchData: ()=>fetchNextData(fetchNextDataParams),\n                asPath: isNotFound ? '/404' : resolvedAs,\n                locale: locale,\n                router: this\n            }).catch((err)=>{\n                // we don't hard error during query updating\n                // as it's un-necessary and doesn't need to be fatal\n                // unless it is a fallback route and the props can't\n                // be loaded\n                if (isQueryUpdating) {\n                    return null;\n                }\n                throw err;\n            });\n            // when rendering error routes we don't apply middleware\n            // effects\n            if (data && (pathname === '/_error' || pathname === '/404')) {\n                data.effect = undefined;\n            }\n            if (isQueryUpdating) {\n                if (!data) {\n                    data = {\n                        json: self.__NEXT_DATA__.props\n                    };\n                } else {\n                    data.json = self.__NEXT_DATA__.props;\n                }\n            }\n            handleCancelled();\n            if (data?.effect?.type === 'redirect-internal' || data?.effect?.type === 'redirect-external') {\n                return data.effect;\n            }\n            if (data?.effect?.type === 'rewrite') {\n                const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                const pages = await this.pageLoader.getPageList();\n                // during query updating the page must match although during\n                // client-transition a redirect that doesn't match a page\n                // can be returned and this should trigger a hard navigation\n                // which is valid for incremental migration\n                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                    route = resolvedRoute;\n                    pathname = data.effect.resolvedHref;\n                    query = {\n                        ...query,\n                        ...data.effect.parsedAs.query\n                    };\n                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);\n                    // Check again the cache with the new destination.\n                    existingInfo = this.components[route];\n                    if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {\n                        // If we have a match with the current route due to rewrite,\n                        // we can copy the existing information to the rewritten one.\n                        // Then, we return the information along with the matched route.\n                        return {\n                            ...existingInfo,\n                            route\n                        };\n                    }\n                }\n            }\n            if ((0, _isapiroute.isAPIRoute)(route)) {\n                handleHardNavigation({\n                    url: as,\n                    router: this\n                });\n                return new Promise(()=>{});\n            }\n            const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res)=>({\n                    Component: res.page,\n                    styleSheets: res.styleSheets,\n                    __N_SSG: res.mod.__N_SSG,\n                    __N_SSP: res.mod.__N_SSP\n                }));\n            if (true) {\n                const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"(pages-dir-browser)/../node_modules/next/dist/compiled/react-is/index.js\");\n                if (!isValidElementType(routeInfo.Component)) {\n                    throw Object.defineProperty(new Error(`The default export is not a React Component in page: \"${pathname}\"`), \"__NEXT_ERROR_CODE\", {\n                        value: \"E286\",\n                        enumerable: false,\n                        configurable: true\n                    });\n                }\n            }\n            const wasBailedPrefetch = data?.response?.headers.get('x-middleware-skip');\n            const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n            // For non-SSG prefetches that bailed before sending data\n            // we clear the cache to fetch full response\n            if (wasBailedPrefetch && data?.dataHref) {\n                delete this.sdc[data.dataHref];\n            }\n            const { props, cacheKey } = await this._getData(async ()=>{\n                if (shouldFetchData) {\n                    if (data?.json && !wasBailedPrefetch) {\n                        return {\n                            cacheKey: data.cacheKey,\n                            props: data.json\n                        };\n                    }\n                    const dataHref = data?.dataHref ? data.dataHref : this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname,\n                            query\n                        }),\n                        asPath: resolvedAs,\n                        locale\n                    });\n                    const fetched = await fetchNextData({\n                        dataHref,\n                        isServerRender: this.isSsr,\n                        parseJSON: true,\n                        inflightCache: wasBailedPrefetch ? {} : this.sdc,\n                        persistCache: !isPreview,\n                        isPrefetch: false,\n                        unstable_skipClientCache\n                    });\n                    return {\n                        cacheKey: fetched.cacheKey,\n                        props: fetched.json || {}\n                    };\n                }\n                return {\n                    headers: {},\n                    props: await this.getInitialProps(routeInfo.Component, {\n                        pathname,\n                        query,\n                        asPath: as,\n                        locale,\n                        locales: this.locales,\n                        defaultLocale: this.defaultLocale\n                    })\n                };\n            });\n            // Only bust the data cache for SSP routes although\n            // middleware can skip cache per request with\n            // x-middleware-cache: no-cache as well\n            if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                delete this.sdc[cacheKey];\n            }\n            // we kick off a HEAD request in the background\n            // when a non-prefetch request is made to signal revalidation\n            if (!this.isPreview && routeInfo.__N_SSG && \"development\" !== 'development' && 0) {}\n            props.pageProps = Object.assign({}, props.pageProps);\n            routeInfo.props = props;\n            routeInfo.route = route;\n            routeInfo.query = query;\n            routeInfo.resolvedAs = resolvedAs;\n            this.components[route] = routeInfo;\n            return routeInfo;\n        } catch (err) {\n            return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);\n        }\n    }\n    set(state, data, resetScroll) {\n        this.state = state;\n        return this.sub(data, this.components['/_app'].Component, resetScroll);\n    }\n    /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ beforePopState(cb) {\n        this._bps = cb;\n    }\n    onlyAHashChange(as) {\n        if (!this.asPath) return false;\n        const [oldUrlNoHash, oldHash] = this.asPath.split('#', 2);\n        const [newUrlNoHash, newHash] = as.split('#', 2);\n        // Makes sure we scroll to the provided hash if the url/hash are the same\n        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n            return true;\n        }\n        // If the urls are change, there's more than a hash change\n        if (oldUrlNoHash !== newUrlNoHash) {\n            return false;\n        }\n        // If the hash has changed, then it's a hash only change.\n        // This check is necessary to handle both the enter and\n        // leave hash === '' cases. The identity case falls through\n        // and is treated as a next reload.\n        return oldHash !== newHash;\n    }\n    scrollToHash(as) {\n        const [, hash = ''] = as.split('#', 2);\n        (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(()=>{\n            // Scroll to top if the hash is just `#` with no value or `#top`\n            // To mirror browsers\n            if (hash === '' || hash === 'top') {\n                window.scrollTo(0, 0);\n                return;\n            }\n            // Decode hash to make non-latin anchor works.\n            const rawHash = decodeURIComponent(hash);\n            // First we check if the element by id is found\n            const idEl = document.getElementById(rawHash);\n            if (idEl) {\n                idEl.scrollIntoView();\n                return;\n            }\n            // If there's no element with the id, we check the `name` property\n            // To mirror browsers\n            const nameEl = document.getElementsByName(rawHash)[0];\n            if (nameEl) {\n                nameEl.scrollIntoView();\n            }\n        }, {\n            onlyHashChange: this.onlyAHashChange(as)\n        });\n    }\n    urlIsNew(asPath) {\n        return this.asPath !== asPath;\n    }\n    /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ async prefetch(url, asPath = url, options = {}) {\n        // Prefetch is not supported in development mode because it would trigger on-demand-entries\n        if (true) {\n            return;\n        }\n        if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n            // No prefetches for bots that render the link since they are typically navigating\n            // links via the equivalent of a hard navigation and hence never utilize these\n            // prefetches.\n            return;\n        }\n        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n        const urlPathname = parsed.pathname;\n        let { pathname, query } = parsed;\n        const originalPathname = pathname;\n        if (false) {}\n        const pages = await this.pageLoader.getPageList();\n        let resolvedAs = asPath;\n        const locale = typeof options.locale !== 'undefined' ? options.locale || undefined : this.locale;\n        const isMiddlewareMatch = await matchesMiddleware({\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        if (false) {}\n        parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n        if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n            pathname = parsed.pathname;\n            parsed.pathname = pathname;\n            Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n            if (!isMiddlewareMatch) {\n                url = (0, _formaturl.formatWithValidation)(parsed);\n            }\n        }\n        const data =  false ? 0 : await withMiddlewareEffects({\n            fetchData: ()=>fetchNextData({\n                    dataHref: this.pageLoader.getDataHref({\n                        href: (0, _formaturl.formatWithValidation)({\n                            pathname: originalPathname,\n                            query\n                        }),\n                        skipInterpolation: true,\n                        asPath: resolvedAs,\n                        locale\n                    }),\n                    hasMiddleware: true,\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true\n                }),\n            asPath: asPath,\n            locale: locale,\n            router: this\n        });\n        /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if (data?.effect.type === 'rewrite') {\n            parsed.pathname = data.effect.resolvedHref;\n            pathname = data.effect.resolvedHref;\n            query = {\n                ...query,\n                ...data.effect.parsedAs.query\n            };\n            resolvedAs = data.effect.parsedAs.pathname;\n            url = (0, _formaturl.formatWithValidation)(parsed);\n        }\n        /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if (data?.effect.type === 'redirect-external') {\n            return;\n        }\n        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        if (await this._bfl(asPath, resolvedAs, options.locale, true)) {\n            this.components[urlPathname] = {\n                __appRouter: true\n            };\n        }\n        await Promise.all([\n            this.pageLoader._isSsg(route).then((isSsg)=>{\n                return isSsg ? fetchNextData({\n                    dataHref: data?.json ? data?.dataHref : this.pageLoader.getDataHref({\n                        href: url,\n                        asPath: resolvedAs,\n                        locale: locale\n                    }),\n                    isServerRender: false,\n                    parseJSON: true,\n                    inflightCache: this.sdc,\n                    persistCache: !this.isPreview,\n                    isPrefetch: true,\n                    unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                }).then(()=>false).catch(()=>false) : false;\n            }),\n            this.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)\n        ]);\n    }\n    async fetchComponent(route) {\n        const handleCancelled = getCancelledHandler({\n            route,\n            router: this\n        });\n        try {\n            const componentResult = await this.pageLoader.loadPage(route);\n            handleCancelled();\n            return componentResult;\n        } catch (err) {\n            handleCancelled();\n            throw err;\n        }\n    }\n    _getData(fn) {\n        let cancelled = false;\n        const cancel = ()=>{\n            cancelled = true;\n        };\n        this.clc = cancel;\n        return fn().then((data)=>{\n            if (cancel === this.clc) {\n                this.clc = null;\n            }\n            if (cancelled) {\n                const err = Object.defineProperty(new Error('Loading initial props cancelled'), \"__NEXT_ERROR_CODE\", {\n                    value: \"E405\",\n                    enumerable: false,\n                    configurable: true\n                });\n                err.cancelled = true;\n                throw err;\n            }\n            return data;\n        });\n    }\n    getInitialProps(Component, ctx) {\n        const { Component: App } = this.components['/_app'];\n        const AppTree = this._wrapApp(App);\n        ctx.AppTree = AppTree;\n        return (0, _utils.loadGetInitialProps)(App, {\n            AppTree,\n            Component,\n            router: this,\n            ctx\n        });\n    }\n    get route() {\n        return this.state.route;\n    }\n    get pathname() {\n        return this.state.pathname;\n    }\n    get query() {\n        return this.state.query;\n    }\n    get asPath() {\n        return this.state.asPath;\n    }\n    get locale() {\n        return this.state.locale;\n    }\n    get isFallback() {\n        return this.state.isFallback;\n    }\n    get isPreview() {\n        return this.state.isPreview;\n    }\n} //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUE0bUJnQkEsU0FBUztlQUFUQTs7SUFpRGhCLE9BaTREQztlQWo0RG9CQzs7SUE1akJDQyxpQkFBaUI7ZUFBakJBOzs7OztpREF4RmM7eUNBSzdCO29DQUNnQzsrRUFDQztpREFDSjtpREFDQTsyRUFDbkI7bUNBQ2tEO3VDQUNwQzs4Q0FDRTswQ0FDRDt3Q0FDRjt1Q0FDTztnREFDRjt1Q0FDVDt1Q0FDQTswQ0FDRzs0Q0FDRTt5Q0FDSDt5Q0FDQTt5Q0FDQTt3Q0FDRDtpREFDUztvREFDRzsyQ0FDSDt3Q0FDVDttQ0FDTDtrQ0FDRDsyQ0FDUztpREFDMkI7dUNBRXJCOzBDQUNKO0FBRWhDLElBQUlDO0FBQ0osSUFBSUMsS0FBK0IsRUFBRSxFQUlwQztBQWdDRCxTQUFTSztJQUNQLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQyxxQkFBNEIsQ0FBNUIsSUFBSUMsTUFBTSxvQkFBVjtlQUFBO29CQUFBO3NCQUFBO0lBQTJCLElBQUc7UUFDakRDLFdBQVc7SUFDYjtBQUNGO0FBU08sZUFBZVgsa0JBQ3BCWSxPQUFrQztJQUVsQyxNQUFNQyxXQUFXLE1BQU1DLFFBQVFDLE9BQU8sQ0FDcENILFFBQVFJLE1BQU0sQ0FBQ0MsVUFBVSxDQUFDQyxhQUFhO0lBRXpDLElBQUksQ0FBQ0wsVUFBVSxPQUFPO0lBRXRCLE1BQU0sRUFBRU0sVUFBVUMsVUFBVSxFQUFFLEdBQUdDLENBQUFBLEdBQUFBLFdBQUFBLFNBQUFBLEVBQVVULFFBQVFVLE1BQU07SUFDekQsNkZBQTZGO0lBQzdGLE1BQU1DLFlBQVlDLENBQUFBLEdBQUFBLGFBQUFBLFdBQUFBLEVBQVlKLGNBQzFCSyxDQUFBQSxHQUFBQSxnQkFBQUEsY0FBQUEsRUFBZUwsY0FDZkE7SUFDSixNQUFNTSwwQkFBMEJDLENBQUFBLEdBQUFBLGFBQUFBLFdB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QVE7SUFDNUI7SUFFQSxJQUFJMkUsUUFBd0I7UUFDMUIsT0FBTyxJQUFJLENBQUNpRyxLQUFLLENBQUNqRyxLQUFLO0lBQ3pCO0lBRUEsSUFBSXhFLFNBQWlCO1FBQ25CLE9BQU8sSUFBSSxDQUFDeUssS0FBSyxDQUFDekssTUFBTTtJQUMxQjtJQUVBLElBQUlPLFNBQTZCO1FBQy9CLE9BQU8sSUFBSSxDQUFDa0ssS0FBSyxDQUFDbEssTUFBTTtJQUMxQjtJQUVBLElBQUl5SixhQUFzQjtRQUN4QixPQUFPLElBQUksQ0FBQ1MsS0FBSyxDQUFDVCxVQUFVO0lBQzlCO0lBRUEsSUFBSUUsWUFBcUI7UUFDdkIsT0FBTyxJQUFJLENBQUNPLEtBQUssQ0FBQ1AsU0FBUztJQUM3QjtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvc2Fuc2tyaXRpa2hhbmFsL0Rlc2t0b3Avc3JjL3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgRG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmVyL2NvbmZpZydcbmltcG9ydCB0eXBlIHsgTWl0dEVtaXR0ZXIgfSBmcm9tICcuLi9taXR0J1xuaW1wb3J0IHR5cGUgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHR5cGUgeyBSb3V0ZXJFdmVudCB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9yb3V0ZXInXG5pbXBvcnQgdHlwZSB7IFN0eWxlU2hlZXRUdXBsZSB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9wYWdlLWxvYWRlcidcbmltcG9ydCB0eXBlIHsgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHR5cGUgUGFnZUxvYWRlciBmcm9tICcuLi8uLi8uLi9jbGllbnQvcGFnZS1sb2FkZXInXG5pbXBvcnQgdHlwZSB7IEFwcENvbnRleHRUeXBlLCBOZXh0UGFnZUNvbnRleHQsIE5FWFRfREFUQSB9IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHsgcmVtb3ZlVHJhaWxpbmdTbGFzaCB9IGZyb20gJy4vdXRpbHMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoJ1xuaW1wb3J0IHtcbiAgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCxcbiAgaXNBc3NldEVycm9yLFxuICBtYXJrQXNzZXRFcnJvcixcbn0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlcidcbmltcG9ydCB7IGhhbmRsZUNsaWVudFNjcmlwdExvYWQgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvc2NyaXB0J1xuaW1wb3J0IGlzRXJyb3IsIHsgZ2V0UHJvcGVyRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9saWIvaXMtZXJyb3InXG5pbXBvcnQgeyBkZW5vcm1hbGl6ZVBhZ2VQYXRoIH0gZnJvbSAnLi4vcGFnZS1wYXRoL2Rlbm9ybWFsaXplLXBhZ2UtcGF0aCdcbmltcG9ydCB7IG5vcm1hbGl6ZUxvY2FsZVBhdGggfSBmcm9tICcuLi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCdcbmltcG9ydCBtaXR0IGZyb20gJy4uL21pdHQnXG5pbXBvcnQgeyBnZXRMb2NhdGlvbk9yaWdpbiwgZ2V0VVJMLCBsb2FkR2V0SW5pdGlhbFByb3BzLCBTVCB9IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHsgaXNEeW5hbWljUm91dGUgfSBmcm9tICcuL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQgeyBwYXJzZVJlbGF0aXZlVXJsIH0gZnJvbSAnLi91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwnXG5pbXBvcnQgeyBnZXRSb3V0ZU1hdGNoZXIgfSBmcm9tICcuL3V0aWxzL3JvdXRlLW1hdGNoZXInXG5pbXBvcnQgeyBnZXRSb3V0ZVJlZ2V4IH0gZnJvbSAnLi91dGlscy9yb3V0ZS1yZWdleCdcbmltcG9ydCB7IGZvcm1hdFdpdGhWYWxpZGF0aW9uIH0gZnJvbSAnLi91dGlscy9mb3JtYXQtdXJsJ1xuaW1wb3J0IHsgZGV0ZWN0RG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2RldGVjdC1kb21haW4tbG9jYWxlJ1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnLi91dGlscy9wYXJzZS1wYXRoJ1xuaW1wb3J0IHsgYWRkTG9jYWxlIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L2FkZC1sb2NhbGUnXG5pbXBvcnQgeyByZW1vdmVMb2NhbGUgfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvcmVtb3ZlLWxvY2FsZSdcbmltcG9ydCB7IHJlbW92ZUJhc2VQYXRoIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1iYXNlLXBhdGgnXG5pbXBvcnQgeyBhZGRCYXNlUGF0aCB9IGZyb20gJy4uLy4uLy4uL2NsaWVudC9hZGQtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaGFzQmFzZVBhdGggfSBmcm9tICcuLi8uLi8uLi9jbGllbnQvaGFzLWJhc2UtcGF0aCdcbmltcG9ydCB7IHJlc29sdmVIcmVmIH0gZnJvbSAnLi4vLi4vLi4vY2xpZW50L3Jlc29sdmUtaHJlZidcbmltcG9ydCB7IGlzQVBJUm91dGUgfSBmcm9tICcuLi8uLi8uLi9saWIvaXMtYXBpLXJvdXRlJ1xuaW1wb3J0IHsgZ2V0TmV4dFBhdGhuYW1lSW5mbyB9IGZyb20gJy4vdXRpbHMvZ2V0LW5leHQtcGF0aG5hbWUtaW5mbydcbmltcG9ydCB7IGZvcm1hdE5leHRQYXRobmFtZUluZm8gfSBmcm9tICcuL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm8nXG5pbXBvcnQgeyBjb21wYXJlUm91dGVyU3RhdGVzIH0gZnJvbSAnLi91dGlscy9jb21wYXJlLXN0YXRlcydcbmltcG9ydCB7IGlzTG9jYWxVUkwgfSBmcm9tICcuL3V0aWxzL2lzLWxvY2FsLXVybCdcbmltcG9ydCB7IGlzQm90IH0gZnJvbSAnLi91dGlscy9pcy1ib3QnXG5pbXBvcnQgeyBvbWl0IH0gZnJvbSAnLi91dGlscy9vbWl0J1xuaW1wb3J0IHsgaW50ZXJwb2xhdGVBcyB9IGZyb20gJy4vdXRpbHMvaW50ZXJwb2xhdGUtYXMnXG5pbXBvcnQgeyBkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uIH0gZnJvbSAnLi91dGlscy9kaXNhYmxlLXNtb290aC1zY3JvbGwnXG5pbXBvcnQgdHlwZSB7IFBhcmFtcyB9IGZyb20gJy4uLy4uLy4uL3NlcnZlci9yZXF1ZXN0L3BhcmFtcydcbmltcG9ydCB7IE1BVENIRURfUEFUSF9IRUFERVIgfSBmcm9tICcuLi8uLi8uLi9saWIvY29uc3RhbnRzJ1xuaW1wb3J0IHsgZ2V0RGVwbG95bWVudElkIH0gZnJvbSAnLi4vZGVwbG95bWVudC1pZCdcblxubGV0IHJlc29sdmVSZXdyaXRlczogdHlwZW9mIGltcG9ydCgnLi91dGlscy9yZXNvbHZlLXJld3JpdGVzJykuZGVmYXVsdFxuaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgcmVzb2x2ZVJld3JpdGVzID0gKFxuICAgIHJlcXVpcmUoJy4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcycpIGFzIHR5cGVvZiBpbXBvcnQoJy4vdXRpbHMvcmVzb2x2ZS1yZXdyaXRlcycpXG4gICkuZGVmYXVsdFxufVxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIC8qIHByb2QgKi9cbiAgICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgfVxufVxuXG5pbnRlcmZhY2UgUm91dGVQcm9wZXJ0aWVzIHtcbiAgc2hhbGxvdzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgVHJhbnNpdGlvbk9wdGlvbnMge1xuICBzaGFsbG93PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuICBzY3JvbGw/OiBib29sZWFuXG4gIHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZT86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIE5leHRIaXN0b3J5U3RhdGUge1xuICB1cmw6IHN0cmluZ1xuICBhczogc3RyaW5nXG4gIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zXG59XG5cbmV4cG9ydCB0eXBlIEhpc3RvcnlTdGF0ZSA9XG4gIHwgbnVsbFxuICB8IHsgX19OQTogdHJ1ZTsgX19OPzogZmFsc2UgfVxuICB8IHsgX19OOiBmYWxzZTsgX19OQT86IGZhbHNlIH1cbiAgfCAoeyBfX05BPzogZmFsc2U7IF9fTjogdHJ1ZTsga2V5OiBzdHJpbmcgfSAmIE5leHRIaXN0b3J5U3RhdGUpXG5cbmZ1bmN0aW9uIGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJyksIHtcbiAgICBjYW5jZWxsZWQ6IHRydWUsXG4gIH0pXG59XG5cbmludGVyZmFjZSBNaWRkbGV3YXJlRWZmZWN0UGFyYW1zPFQgZXh0ZW5kcyBGZXRjaERhdGFPdXRwdXQ+IHtcbiAgZmV0Y2hEYXRhPzogKCkgPT4gUHJvbWlzZTxUPlxuICBsb2NhbGU/OiBzdHJpbmdcbiAgYXNQYXRoOiBzdHJpbmdcbiAgcm91dGVyOiBSb3V0ZXJcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1hdGNoZXNNaWRkbGV3YXJlPFQgZXh0ZW5kcyBGZXRjaERhdGFPdXRwdXQ+KFxuICBvcHRpb25zOiBNaWRkbGV3YXJlRWZmZWN0UGFyYW1zPFQ+XG4pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgY29uc3QgbWF0Y2hlcnMgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUoXG4gICAgb3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKClcbiAgKVxuICBpZiAoIW1hdGNoZXJzKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lIH0gPSBwYXJzZVBhdGgob3B0aW9ucy5hc1BhdGgpXG4gIC8vIHJlbW92ZSBiYXNlUGF0aCBmaXJzdCBzaW5jZSBwYXRoIHByZWZpeCBoYXMgdG8gYmUgaW4gdGhlIG9yZGVyIG9mIGAvJHtiYXNlUGF0aH0vJHtsb2NhbGV9YFxuICBjb25zdCBjbGVhbmVkQXMgPSBoYXNCYXNlUGF0aChhc1BhdGhuYW1lKVxuICAgID8gcmVtb3ZlQmFzZVBhdGgoYXNQYXRobmFtZSlcbiAgICA6IGFzUGF0aG5hbWVcbiAgY29uc3QgYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUgPSBhZGRCYXNlUGF0aChcbiAgICBhZGRMb2NhbGUoY2xlYW5lZEFzLCBvcHRpb25zLmxvY2FsZSlcbiAgKVxuXG4gIC8vIENoZWNrIG9ubHkgcGF0aCBtYXRjaCBvbiBjbGllbnQuIE1hdGNoaW5nIFwiaGFzXCIgc2hvdWxkIGJlIGRvbmUgb24gc2VydmVyXG4gIC8vIHdoZXJlIHdlIGNhbiBhY2Nlc3MgbW9yZSBpbmZvIHN1Y2ggYXMgaGVhZGVycywgSHR0cE9ubHkgY29va2llLCBldGMuXG4gIHJldHVybiBtYXRjaGVycy5zb21lKChtKSA9PlxuICAgIG5ldyBSZWdFeHAobS5yZWdleHApLnRlc3QoYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUpXG4gIClcbn1cblxuZnVuY3Rpb24gc3RyaXBPcmlnaW4odXJsOiBzdHJpbmcpIHtcbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuXG4gIHJldHVybiB1cmwuc3RhcnRzV2l0aChvcmlnaW4pID8gdXJsLnN1YnN0cmluZyhvcmlnaW4ubGVuZ3RoKSA6IHVybFxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXJsQXMocm91dGVyOiBOZXh0Um91dGVyLCB1cmw6IFVybCwgYXM/OiBVcmwpIHtcbiAgLy8gSWYgdXJsIGFuZCBhcyBwcm92aWRlZCBhcyBhbiBvYmplY3QgcmVwcmVzZW50YXRpb24sXG4gIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gIGxldCBbcmVzb2x2ZWRIcmVmLCByZXNvbHZlZEFzXSA9IHJlc29sdmVIcmVmKHJvdXRlciwgdXJsLCB0cnVlKVxuICBjb25zdCBvcmlnaW4gPSBnZXRMb2NhdGlvbk9yaWdpbigpXG4gIGNvbnN0IGhyZWZXYXNBYnNvbHV0ZSA9IHJlc29sdmVkSHJlZi5zdGFydHNXaXRoKG9yaWdpbilcbiAgY29uc3QgYXNXYXNBYnNvbHV0ZSA9IHJlc29sdmVkQXMgJiYgcmVzb2x2ZWRBcy5zdGFydHNXaXRoKG9yaWdpbilcblxuICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpXG4gIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzXG5cbiAgY29uc3QgcHJlcGFyZWRVcmwgPSBocmVmV2FzQWJzb2x1dGUgPyByZXNvbHZlZEhyZWYgOiBhZGRCYXNlUGF0aChyZXNvbHZlZEhyZWYpXG4gIGNvbnN0IHByZXBhcmVkQXMgPSBhc1xuICAgID8gc3RyaXBPcmlnaW4ocmVzb2x2ZUhyZWYocm91dGVyLCBhcykpXG4gICAgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZlxuXG4gIHJldHVybiB7XG4gICAgdXJsOiBwcmVwYXJlZFVybCxcbiAgICBhczogYXNXYXNBYnNvbHV0ZSA/IHByZXBhcmVkQXMgOiBhZGRCYXNlUGF0aChwcmVwYXJlZEFzKSxcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lOiBzdHJpbmcsIHBhZ2VzOiBzdHJpbmdbXSkge1xuICBjb25zdCBjbGVhblBhdGhuYW1lID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChkZW5vcm1hbGl6ZVBhZ2VQYXRoKHBhdGhuYW1lKSlcbiAgaWYgKGNsZWFuUGF0aG5hbWUgPT09ICcvNDA0JyB8fCBjbGVhblBhdGhuYW1lID09PSAnL19lcnJvcicpIHtcbiAgICByZXR1cm4gcGF0aG5hbWVcbiAgfVxuXG4gIC8vIGhhbmRsZSByZXNvbHZpbmcgaHJlZiBmb3IgZHluYW1pYyByb3V0ZXNcbiAgaWYgKCFwYWdlcy5pbmNsdWRlcyhjbGVhblBhdGhuYW1lKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBhcnJheS1jYWxsYmFjay1yZXR1cm5cbiAgICBwYWdlcy5zb21lKChwYWdlKSA9PiB7XG4gICAgICBpZiAoaXNEeW5hbWljUm91dGUocGFnZSkgJiYgZ2V0Um91dGVSZWdleChwYWdlKS5yZS50ZXN0KGNsZWFuUGF0aG5hbWUpKSB7XG4gICAgICAgIHBhdGhuYW1lID0gcGFnZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG59XG5cbmZ1bmN0aW9uIGdldE1pZGRsZXdhcmVEYXRhPFQgZXh0ZW5kcyBGZXRjaERhdGFPdXRwdXQ+KFxuICBzb3VyY2U6IHN0cmluZyxcbiAgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICBvcHRpb25zOiBNaWRkbGV3YXJlRWZmZWN0UGFyYW1zPFQ+XG4pIHtcbiAgY29uc3QgbmV4dENvbmZpZyA9IHtcbiAgICBiYXNlUGF0aDogb3B0aW9ucy5yb3V0ZXIuYmFzZVBhdGgsXG4gICAgaTE4bjogeyBsb2NhbGVzOiBvcHRpb25zLnJvdXRlci5sb2NhbGVzIH0sXG4gICAgdHJhaWxpbmdTbGFzaDogQm9vbGVhbihwcm9jZXNzLmVudi5fX05FWFRfVFJBSUxJTkdfU0xBU0gpLFxuICB9XG4gIGNvbnN0IHJld3JpdGVIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldCgneC1uZXh0anMtcmV3cml0ZScpXG5cbiAgbGV0IHJld3JpdGVUYXJnZXQgPVxuICAgIHJld3JpdGVIZWFkZXIgfHwgcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbmV4dGpzLW1hdGNoZWQtcGF0aCcpXG5cbiAgY29uc3QgbWF0Y2hlZFBhdGggPSByZXNwb25zZS5oZWFkZXJzLmdldChNQVRDSEVEX1BBVEhfSEVBREVSKVxuXG4gIGlmIChcbiAgICBtYXRjaGVkUGF0aCAmJlxuICAgICFyZXdyaXRlVGFyZ2V0ICYmXG4gICAgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKCdfX25leHRfZGF0YV9jYXRjaGFsbCcpICYmXG4gICAgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKCcvX2Vycm9yJykgJiZcbiAgICAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoJy80MDQnKVxuICApIHtcbiAgICAvLyBsZXZlcmFnZSB4LW1hdGNoZWQtcGF0aCB0byBkZXRlY3QgbmV4dC5jb25maWcuanMgcmV3cml0ZXNcbiAgICByZXdyaXRlVGFyZ2V0ID0gbWF0Y2hlZFBhdGhcbiAgfVxuXG4gIGlmIChyZXdyaXRlVGFyZ2V0KSB7XG4gICAgaWYgKFxuICAgICAgcmV3cml0ZVRhcmdldC5zdGFydHNXaXRoKCcvJykgfHxcbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRVxuICAgICkge1xuICAgICAgY29uc3QgcGFyc2VkUmV3cml0ZVRhcmdldCA9IHBhcnNlUmVsYXRpdmVVcmwocmV3cml0ZVRhcmdldClcbiAgICAgIGNvbnN0IHBhdGhuYW1lSW5mbyA9IGdldE5leHRQYXRobmFtZUluZm8ocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSwge1xuICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICBwYXJzZURhdGE6IHRydWUsXG4gICAgICB9KVxuXG4gICAgICBsZXQgZnNQYXRobmFtZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWVJbmZvLnBhdGhuYW1lKVxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgb3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCksXG4gICAgICBdKS50aGVuKChbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgfV06IGFueSkgPT4ge1xuICAgICAgICBsZXQgYXMgPSBhZGRMb2NhbGUocGF0aG5hbWVJbmZvLnBhdGhuYW1lLCBwYXRobmFtZUluZm8ubG9jYWxlKVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBpc0R5bmFtaWNSb3V0ZShhcykgfHxcbiAgICAgICAgICAoIXJld3JpdGVIZWFkZXIgJiZcbiAgICAgICAgICAgIHBhZ2VzLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBub3JtYWxpemVMb2NhbGVQYXRoKHJlbW92ZUJhc2VQYXRoKGFzKSwgb3B0aW9ucy5yb3V0ZXIubG9jYWxlcylcbiAgICAgICAgICAgICAgICAucGF0aG5hbWVcbiAgICAgICAgICAgICkpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHBhcnNlZFNvdXJjZSA9IGdldE5leHRQYXRobmFtZUluZm8oXG4gICAgICAgICAgICBwYXJzZVJlbGF0aXZlVXJsKHNvdXJjZSkucGF0aG5hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5leHRDb25maWc6IHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVNcbiAgICAgICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIDogbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgcGFyc2VEYXRhOiB0cnVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcblxuICAgICAgICAgIGFzID0gYWRkQmFzZVBhdGgocGFyc2VkU291cmNlLnBhdGhuYW1lKVxuICAgICAgICAgIHBhcnNlZFJld3JpdGVUYXJnZXQucGF0aG5hbWUgPSBhc1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIHBhZ2VzLFxuICAgICAgICAgICAgcmV3cml0ZXMsXG4gICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LFxuICAgICAgICAgICAgKHBhdGg6IHN0cmluZykgPT4gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRoLCBwYWdlcyksXG4gICAgICAgICAgICBvcHRpb25zLnJvdXRlci5sb2NhbGVzXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKHJlc3VsdC5tYXRjaGVkUGFnZSkge1xuICAgICAgICAgICAgcGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSA9IHJlc3VsdC5wYXJzZWRBcy5wYXRobmFtZVxuICAgICAgICAgICAgYXMgPSBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIHJlc3VsdC5wYXJzZWRBcy5xdWVyeSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpKSB7XG4gICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgcGFnZXMpXG5cbiAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRobmFtZSAhPT0gZnNQYXRobmFtZSkge1xuICAgICAgICAgICAgZnNQYXRobmFtZSA9IHJlc29sdmVkUGF0aG5hbWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXNvbHZlZEhyZWYgPSAhcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSlcbiAgICAgICAgICA/IHJlc29sdmVEeW5hbWljUm91dGUoXG4gICAgICAgICAgICAgIG5vcm1hbGl6ZUxvY2FsZVBhdGgoXG4gICAgICAgICAgICAgICAgcmVtb3ZlQmFzZVBhdGgocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSksXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXIubG9jYWxlc1xuICAgICAgICAgICAgICApLnBhdGhuYW1lLFxuICAgICAgICAgICAgICBwYWdlc1xuICAgICAgICAgICAgKVxuICAgICAgICAgIDogZnNQYXRobmFtZVxuXG4gICAgICAgIGlmIChpc0R5bmFtaWNSb3V0ZShyZXNvbHZlZEhyZWYpKSB7XG4gICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGdldFJvdXRlTWF0Y2hlcihnZXRSb3V0ZVJlZ2V4KHJlc29sdmVkSHJlZikpKGFzKVxuICAgICAgICAgIE9iamVjdC5hc3NpZ24ocGFyc2VkUmV3cml0ZVRhcmdldC5xdWVyeSwgbWF0Y2hlcyB8fCB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3Jld3JpdGUnIGFzIGNvbnN0LFxuICAgICAgICAgIHBhcnNlZEFzOiBwYXJzZWRSZXdyaXRlVGFyZ2V0LFxuICAgICAgICAgIHJlc29sdmVkSHJlZixcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgY29uc3Qgc3JjID0gcGFyc2VQYXRoKHNvdXJjZSlcbiAgICBjb25zdCBwYXRobmFtZSA9IGZvcm1hdE5leHRQYXRobmFtZUluZm8oe1xuICAgICAgLi4uZ2V0TmV4dFBhdGhuYW1lSW5mbyhzcmMucGF0aG5hbWUsIHsgbmV4dENvbmZpZywgcGFyc2VEYXRhOiB0cnVlIH0pLFxuICAgICAgZGVmYXVsdExvY2FsZTogb3B0aW9ucy5yb3V0ZXIuZGVmYXVsdExvY2FsZSxcbiAgICAgIGJ1aWxkSWQ6ICcnLFxuICAgIH0pXG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHR5cGU6ICdyZWRpcmVjdC1leHRlcm5hbCcgYXMgY29uc3QsXG4gICAgICBkZXN0aW5hdGlvbjogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gLFxuICAgIH0pXG4gIH1cblxuICBjb25zdCByZWRpcmVjdFRhcmdldCA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LW5leHRqcy1yZWRpcmVjdCcpXG5cbiAgaWYgKHJlZGlyZWN0VGFyZ2V0KSB7XG4gICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgY29uc3Qgc3JjID0gcGFyc2VQYXRoKHJlZGlyZWN0VGFyZ2V0KVxuICAgICAgY29uc3QgcGF0aG5hbWUgPSBmb3JtYXROZXh0UGF0aG5hbWVJbmZvKHtcbiAgICAgICAgLi4uZ2V0TmV4dFBhdGhuYW1lSW5mbyhzcmMucGF0aG5hbWUsIHsgbmV4dENvbmZpZywgcGFyc2VEYXRhOiB0cnVlIH0pLFxuICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICBidWlsZElkOiAnJyxcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB0eXBlOiAncmVkaXJlY3QtaW50ZXJuYWwnIGFzIGNvbnN0LFxuICAgICAgICBuZXdBczogYCR7cGF0aG5hbWV9JHtzcmMucXVlcnl9JHtzcmMuaGFzaH1gLFxuICAgICAgICBuZXdVcmw6IGAke3BhdGhuYW1lfSR7c3JjLnF1ZXJ5fSR7c3JjLmhhc2h9YCxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICB0eXBlOiAncmVkaXJlY3QtZXh0ZXJuYWwnIGFzIGNvbnN0LFxuICAgICAgZGVzdGluYXRpb246IHJlZGlyZWN0VGFyZ2V0LFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgdHlwZTogJ25leHQnIGFzIGNvbnN0IH0pXG59XG5cbmludGVyZmFjZSBXaXRoTWlkZGxld2FyZUVmZmVjdHNPdXRwdXQgZXh0ZW5kcyBGZXRjaERhdGFPdXRwdXQge1xuICBlZmZlY3Q6IEF3YWl0ZWQ8UmV0dXJuVHlwZTx0eXBlb2YgZ2V0TWlkZGxld2FyZURhdGE+PlxufVxuXG5hc3luYyBmdW5jdGlvbiB3aXRoTWlkZGxld2FyZUVmZmVjdHM8VCBleHRlbmRzIEZldGNoRGF0YU91dHB1dD4oXG4gIG9wdGlvbnM6IE1pZGRsZXdhcmVFZmZlY3RQYXJhbXM8VD5cbik6IFByb21pc2U8V2l0aE1pZGRsZXdhcmVFZmZlY3RzT3V0cHV0IHwgbnVsbD4ge1xuICBjb25zdCBtYXRjaGVzID0gYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUob3B0aW9ucylcbiAgaWYgKCFtYXRjaGVzIHx8ICFvcHRpb25zLmZldGNoRGF0YSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICBjb25zdCBkYXRhID0gYXdhaXQgb3B0aW9ucy5mZXRjaERhdGEoKVxuXG4gIGNvbnN0IGVmZmVjdCA9IGF3YWl0IGdldE1pZGRsZXdhcmVEYXRhKGRhdGEuZGF0YUhyZWYsIGRhdGEucmVzcG9uc2UsIG9wdGlvbnMpXG5cbiAgcmV0dXJuIHtcbiAgICBkYXRhSHJlZjogZGF0YS5kYXRhSHJlZixcbiAgICBqc29uOiBkYXRhLmpzb24sXG4gICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXG4gICAgdGV4dDogZGF0YS50ZXh0LFxuICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgIGVmZmVjdCxcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBVcmwgPSBVcmxPYmplY3QgfCBzdHJpbmdcblxuZXhwb3J0IHR5cGUgQmFzZVJvdXRlciA9IHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG4gIGxvY2FsZT86IHN0cmluZyB8IHVuZGVmaW5lZFxuICBsb2NhbGVzPzogcmVhZG9ubHkgc3RyaW5nW10gfCB1bmRlZmluZWRcbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZyB8IHVuZGVmaW5lZFxuICBkb21haW5Mb2NhbGVzPzogcmVhZG9ubHkgRG9tYWluTG9jYWxlW10gfCB1bmRlZmluZWRcbiAgaXNMb2NhbGVEb21haW46IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgTmV4dFJvdXRlciA9IEJhc2VSb3V0ZXIgJlxuICBQaWNrPFxuICAgIFJvdXRlcixcbiAgICB8ICdwdXNoJ1xuICAgIHwgJ3JlcGxhY2UnXG4gICAgfCAncmVsb2FkJ1xuICAgIHwgJ2JhY2snXG4gICAgfCAnZm9yd2FyZCdcbiAgICB8ICdwcmVmZXRjaCdcbiAgICB8ICdiZWZvcmVQb3BTdGF0ZSdcbiAgICB8ICdldmVudHMnXG4gICAgfCAnaXNGYWxsYmFjaydcbiAgICB8ICdpc1JlYWR5J1xuICAgIHwgJ2lzUHJldmlldydcbiAgPlxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIHByaW9yaXR5PzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmcgfCBmYWxzZVxuICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFByaXZhdGVSb3V0ZUluZm8gPVxuICB8IChPbWl0PENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ3N0eWxlU2hlZXRzJz4gJiB7IGluaXRpYWw6IHRydWUgfSlcbiAgfCBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm9cblxuZXhwb3J0IHR5cGUgQ29tcGxldGVQcml2YXRlUm91dGVJbmZvID0ge1xuICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgc3R5bGVTaGVldHM6IFN0eWxlU2hlZXRUdXBsZVtdXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG4gIHByb3BzPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBlcnI/OiBFcnJvclxuICBlcnJvcj86IGFueVxuICByb3V0ZT86IHN0cmluZ1xuICByZXNvbHZlZEFzPzogc3RyaW5nXG4gIHF1ZXJ5PzogUGFyc2VkVXJsUXVlcnlcbn1cblxuZXhwb3J0IHR5cGUgQXBwUHJvcHMgPSBQaWNrPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbywgJ0NvbXBvbmVudCcgfCAnZXJyJz4gJiB7XG4gIHJvdXRlcjogUm91dGVyXG59ICYgUmVjb3JkPHN0cmluZywgYW55PlxuZXhwb3J0IHR5cGUgQXBwQ29tcG9uZW50ID0gQ29tcG9uZW50VHlwZTxBcHBQcm9wcz5cblxudHlwZSBTdWJzY3JpcHRpb24gPSAoXG4gIGRhdGE6IFByaXZhdGVSb3V0ZUluZm8sXG4gIEFwcDogQXBwQ29tcG9uZW50LFxuICByZXNldFNjcm9sbDogeyB4OiBudW1iZXI7IHk6IG51bWJlciB9IHwgbnVsbFxuKSA9PiBQcm9taXNlPHZvaWQ+XG5cbnR5cGUgQmVmb3JlUG9wU3RhdGVDYWxsYmFjayA9IChzdGF0ZTogTmV4dEhpc3RvcnlTdGF0ZSkgPT4gYm9vbGVhblxuXG50eXBlIENvbXBvbmVudExvYWRDYW5jZWwgPSAoKCkgPT4gdm9pZCkgfCBudWxsXG5cbnR5cGUgSGlzdG9yeU1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnIHwgJ3B1c2hTdGF0ZSdcblxuY29uc3QgbWFudWFsU2Nyb2xsUmVzdG9yYXRpb24gPVxuICBwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OICYmXG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICdzY3JvbGxSZXN0b3JhdGlvbicgaW4gd2luZG93Lmhpc3RvcnkgJiZcbiAgISEoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgdiA9ICdfX25leHQnXG4gICAgICByZXR1cm4gKHNlc3Npb25TdG9yYWdlLnNldEl0ZW0odiwgdiksIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odiksIHRydWUpXG4gICAgfSBjYXRjaCAobikge31cbiAgfSkoKVxuXG5jb25zdCBTU0dfREFUQV9OT1RfRk9VTkQgPSBTeW1ib2woJ1NTR19EQVRBX05PVF9GT1VORCcpXG5cbmZ1bmN0aW9uIGZldGNoUmV0cnkoXG4gIHVybDogc3RyaW5nLFxuICBhdHRlbXB0czogbnVtYmVyLFxuICBvcHRpb25zOiBQaWNrPFJlcXVlc3RJbml0LCAnbWV0aG9kJyB8ICdoZWFkZXJzJz5cbik6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgIC8vIENvb2tpZXMgYXJlIHJlcXVpcmVkIHRvIGJlIHByZXNlbnQgZm9yIE5leHQuanMnIFNTRyBcIlByZXZpZXcgTW9kZVwiLlxuICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgIC8vXG4gICAgLy8gPiBgZmV0Y2hgIHdvbuKAmXQgc2VuZCBjb29raWVzLCB1bmxlc3MgeW91IHNldCB0aGUgY3JlZGVudGlhbHMgaW5pdFxuICAgIC8vID4gb3B0aW9uLlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAvL1xuICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgIC8vID4gb3B0aW9uIGluc3RlYWQgb2YgcmVseWluZyBvbiB0aGUgZGVmYXVsdC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyxcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnLFxuICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgJ3gtbmV4dGpzLWRhdGEnOiAnMScsXG4gICAgfSksXG4gIH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgcmV0dXJuICFyZXNwb25zZS5vayAmJiBhdHRlbXB0cyA+IDEgJiYgcmVzcG9uc2Uuc3RhdHVzID49IDUwMFxuICAgICAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKVxuICAgICAgOiByZXNwb25zZVxuICB9KVxufVxuXG5pbnRlcmZhY2UgRmV0Y2hEYXRhT3V0cHV0IHtcbiAgZGF0YUhyZWY6IHN0cmluZ1xuICBqc29uOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgbnVsbFxuICByZXNwb25zZTogUmVzcG9uc2VcbiAgdGV4dDogc3RyaW5nXG4gIGNhY2hlS2V5OiBzdHJpbmdcbn1cblxuaW50ZXJmYWNlIEZldGNoTmV4dERhdGFQYXJhbXMge1xuICBkYXRhSHJlZjogc3RyaW5nXG4gIGlzU2VydmVyUmVuZGVyOiBib29sZWFuXG4gIHBhcnNlSlNPTjogYm9vbGVhbiB8IHVuZGVmaW5lZFxuICBoYXNNaWRkbGV3YXJlPzogYm9vbGVhblxuICBpbmZsaWdodENhY2hlOiBOZXh0RGF0YUNhY2hlXG4gIHBlcnNpc3RDYWNoZTogYm9vbGVhblxuICBpc1ByZWZldGNoOiBib29sZWFuXG4gIGlzQmFja2dyb3VuZD86IGJvb2xlYW5cbiAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlPzogYm9vbGVhblxufVxuXG5mdW5jdGlvbiB0cnlUb1BhcnNlQXNKU09OKHRleHQ6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBmZXRjaE5leHREYXRhKHtcbiAgZGF0YUhyZWYsXG4gIGluZmxpZ2h0Q2FjaGUsXG4gIGlzUHJlZmV0Y2gsXG4gIGhhc01pZGRsZXdhcmUsXG4gIGlzU2VydmVyUmVuZGVyLFxuICBwYXJzZUpTT04sXG4gIHBlcnNpc3RDYWNoZSxcbiAgaXNCYWNrZ3JvdW5kLFxuICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG59OiBGZXRjaE5leHREYXRhUGFyYW1zKTogUHJvbWlzZTxGZXRjaERhdGFPdXRwdXQ+IHtcbiAgY29uc3QgeyBocmVmOiBjYWNoZUtleSB9ID0gbmV3IFVSTChkYXRhSHJlZiwgd2luZG93LmxvY2F0aW9uLmhyZWYpXG4gIGNvbnN0IGRlcGxveW1lbnRJZCA9IGdldERlcGxveW1lbnRJZCgpXG4gIGNvbnN0IGdldERhdGEgPSAocGFyYW1zPzogeyBtZXRob2Q/OiAnSEVBRCcgfCAnR0VUJyB9KSA9PlxuICAgIGZldGNoUmV0cnkoZGF0YUhyZWYsIGlzU2VydmVyUmVuZGVyID8gMyA6IDEsIHtcbiAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9IGFzIEhlYWRlcnNJbml0LFxuICAgICAgICBpc1ByZWZldGNoID8geyBwdXJwb3NlOiAncHJlZmV0Y2gnIH0gOiB7fSxcbiAgICAgICAgaXNQcmVmZXRjaCAmJiBoYXNNaWRkbGV3YXJlID8geyAneC1taWRkbGV3YXJlLXByZWZldGNoJzogJzEnIH0gOiB7fSxcbiAgICAgICAgZGVwbG95bWVudElkID8geyAneC1kZXBsb3ltZW50LWlkJzogZGVwbG95bWVudElkIH0gOiB7fVxuICAgICAgKSxcbiAgICAgIG1ldGhvZDogcGFyYW1zPy5tZXRob2QgPz8gJ0dFVCcsXG4gICAgfSlcbiAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgcGFyYW1zPy5tZXRob2QgPT09ICdIRUFEJykge1xuICAgICAgICAgIHJldHVybiB7IGRhdGFIcmVmLCByZXNwb25zZSwgdGV4dDogJycsIGpzb246IHt9LCBjYWNoZUtleSB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpLnRoZW4oKHRleHQpID0+IHtcbiAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gdGhlIGRhdGEgcmVzcG9uc2UgaXMgYSByZWRpcmVjdCBiZWNhdXNlIG9mIGEgbWlkZGxld2FyZVxuICAgICAgICAgICAgICogd2UgZG8gbm90IGNvbnNpZGVyIGl0IGFuIGVycm9yLiBUaGUgaGVhZGVycyBtdXN0IGJyaW5nIHRoZVxuICAgICAgICAgICAgICogbWFwcGVkIGxvY2F0aW9uLlxuICAgICAgICAgICAgICogVE9ETzogQ2hhbmdlIHRoZSBzdGF0dXMgY29kZSBpbiB0aGUgaGFuZGxlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlICYmXG4gICAgICAgICAgICAgIFszMDEsIDMwMiwgMzA3LCAzMDhdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICByZXR1cm4geyBkYXRhSHJlZiwgcmVzcG9uc2UsIHRleHQsIGpzb246IHt9LCBjYWNoZUtleSB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICBpZiAodHJ5VG9QYXJzZUFzSlNPTih0ZXh0KT8ubm90Rm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICBqc29uOiB7IG5vdEZvdW5kOiBTU0dfREFUQV9OT1RfRk9VTkQgfSxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3RhdGljIHByb3BzYClcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSBzaG91bGQgb25seSB0cmlnZ2VyIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbiBpZiB0aGlzIHdhc1xuICAgICAgICAgICAgICogY2F1c2VkIG9uIGEgY2xpZW50LXNpZGUgdHJhbnNpdGlvbi4gT3RoZXJ3aXNlLCB3ZSdkIGdldCBpbnRvXG4gICAgICAgICAgICAgKiBhbiBpbmZpbml0ZSBsb29wLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgIG1hcmtBc3NldEVycm9yKGVycm9yKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgIGpzb246IHBhcnNlSlNPTiA/IHRyeVRvUGFyc2VBc0pTT04odGV4dCkgOiBudWxsLFxuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgY2FjaGVLZXksXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhcGVyc2lzdENhY2hlIHx8XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyB8fFxuICAgICAgICAgIGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1jYWNoZScpID09PSAnbm8tY2FjaGUnXG4gICAgICAgICkge1xuICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKCF1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUpIHtcbiAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gY2hyb21lXG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPT09ICdGYWlsZWQgdG8gZmV0Y2gnIHx8XG4gICAgICAgICAgLy8gZmlyZWZveFxuICAgICAgICAgIGVyci5tZXNzYWdlID09PSAnTmV0d29ya0Vycm9yIHdoZW4gYXR0ZW1wdGluZyB0byBmZXRjaCByZXNvdXJjZS4nIHx8XG4gICAgICAgICAgLy8gc2FmYXJpXG4gICAgICAgICAgZXJyLm1lc3NhZ2UgPT09ICdMb2FkIGZhaWxlZCdcbiAgICAgICAgKSB7XG4gICAgICAgICAgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfSlcblxuICAvLyB3aGVuIHNraXBwaW5nIGNsaWVudCBjYWNoZSB3ZSB3YWl0IHRvIHVwZGF0ZVxuICAvLyBpbmZsaWdodCBjYWNoZSB1bnRpbCBzdWNjZXNzZnVsIGRhdGEgcmVzcG9uc2VcbiAgLy8gdGhpcyBhbGxvd3MgcmFjaW5nIGNsaWNrIGV2ZW50IHdpdGggZmV0Y2hpbmcgbmV3ZXIgZGF0YVxuICAvLyB3aXRob3V0IGJsb2NraW5nIG5hdmlnYXRpb24gd2hlbiBzdGFsZSBkYXRhIGlzIGF2YWlsYWJsZVxuICBpZiAodW5zdGFibGVfc2tpcENsaWVudENhY2hlICYmIHBlcnNpc3RDYWNoZSkge1xuICAgIHJldHVybiBnZXREYXRhKHt9KS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoZGF0YS5yZXNwb25zZS5oZWFkZXJzLmdldCgneC1taWRkbGV3YXJlLWNhY2hlJykgIT09ICduby1jYWNoZScpIHtcbiAgICAgICAgLy8gb25seSB1cGRhdGUgY2FjaGUgaWYgbm90IG1hcmtlZCBhcyBuby1jYWNoZVxuICAgICAgICBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IFByb21pc2UucmVzb2x2ZShkYXRhKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBpZiAoaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBpbmZsaWdodENhY2hlW2NhY2hlS2V5XVxuICB9XG4gIHJldHVybiAoaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBnZXREYXRhKFxuICAgIGlzQmFja2dyb3VuZCA/IHsgbWV0aG9kOiAnSEVBRCcgfSA6IHt9XG4gICkpXG59XG5cbmludGVyZmFjZSBOZXh0RGF0YUNhY2hlIHtcbiAgW2FzUGF0aDogc3RyaW5nXTogUHJvbWlzZTxGZXRjaERhdGFPdXRwdXQ+XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMClcbn1cblxuZnVuY3Rpb24gaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICB1cmwsXG4gIHJvdXRlcixcbn06IHtcbiAgdXJsOiBzdHJpbmdcbiAgcm91dGVyOiBSb3V0ZXJcbn0pIHtcbiAgLy8gZW5zdXJlIHdlIGRvbid0IHRyaWdnZXIgYSBoYXJkIG5hdmlnYXRpb24gdG8gdGhlIHNhbWVcbiAgLy8gVVJMIGFzIHRoaXMgY2FuIGVuZCB1cCB3aXRoIGFuIGluZmluaXRlIHJlZnJlc2hcbiAgaWYgKHVybCA9PT0gYWRkQmFzZVBhdGgoYWRkTG9jYWxlKHJvdXRlci5hc1BhdGgsIHJvdXRlci5sb2NhbGUpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBJbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBoYXJkIG5hdmlnYXRlIHRvIHRoZSBzYW1lIFVSTCAke3VybH0gJHtsb2NhdGlvbi5ocmVmfWBcbiAgICApXG4gIH1cbiAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmxcbn1cblxuY29uc3QgZ2V0Q2FuY2VsbGVkSGFuZGxlciA9ICh7XG4gIHJvdXRlLFxuICByb3V0ZXIsXG59OiB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcm91dGVyOiBSb3V0ZXJcbn0pID0+IHtcbiAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gIGNvbnN0IGNhbmNlbCA9IChyb3V0ZXIuY2xjID0gKCkgPT4ge1xuICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgfSlcblxuICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKSA9PiB7XG4gICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgY29uc3QgZXJyb3I6IGFueSA9IG5ldyBFcnJvcihcbiAgICAgICAgYEFib3J0IGZldGNoaW5nIGNvbXBvbmVudCBmb3Igcm91dGU6IFwiJHtyb3V0ZX1cImBcbiAgICAgIClcbiAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgaWYgKGNhbmNlbCA9PT0gcm91dGVyLmNsYykge1xuICAgICAgcm91dGVyLmNsYyA9IG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhbmRsZUNhbmNlbGxlZFxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIgaW1wbGVtZW50cyBCYXNlUm91dGVyIHtcbiAgYmFzZVBhdGg6IHN0cmluZ1xuXG4gIC8qKlxuICAgKiBNYXAgb2YgYWxsIGNvbXBvbmVudHMgbG9hZGVkIGluIGBSb3V0ZXJgXG4gICAqL1xuICBjb21wb25lbnRzOiB7IFtwYXRobmFtZTogc3RyaW5nXTogUHJpdmF0ZVJvdXRlSW5mbyB9XG4gIC8vIFNlcnZlciBEYXRhIENhY2hlIChmdWxsIGRhdGEgcmVxdWVzdHMpXG4gIHNkYzogTmV4dERhdGFDYWNoZSA9IHt9XG4gIC8vIFNlcnZlciBCYWNrZ3JvdW5kIENhY2hlIChIRUFEIHJlcXVlc3RzKVxuICBzYmM6IE5leHREYXRhQ2FjaGUgPSB7fVxuXG4gIHN1YjogU3Vic2NyaXB0aW9uXG4gIGNsYzogQ29tcG9uZW50TG9hZENhbmNlbFxuICBwYWdlTG9hZGVyOiBQYWdlTG9hZGVyXG4gIF9icHM6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgfCB1bmRlZmluZWRcbiAgZXZlbnRzOiBNaXR0RW1pdHRlcjxSb3V0ZXJFdmVudD5cbiAgX3dyYXBBcHA6IChBcHA6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gIGlzU3NyOiBib29sZWFuXG4gIF9pbkZsaWdodFJvdXRlPzogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIF9zaGFsbG93PzogYm9vbGVhbiB8IHVuZGVmaW5lZFxuICBsb2NhbGVzPzogcmVhZG9ubHkgc3RyaW5nW10gfCB1bmRlZmluZWRcbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZyB8IHVuZGVmaW5lZFxuICBkb21haW5Mb2NhbGVzPzogcmVhZG9ubHkgRG9tYWluTG9jYWxlW10gfCB1bmRlZmluZWRcbiAgaXNSZWFkeTogYm9vbGVhblxuICBpc0xvY2FsZURvbWFpbjogYm9vbGVhblxuICBpc0ZpcnN0UG9wU3RhdGVFdmVudCA9IHRydWVcbiAgX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2U6IFByb21pc2U8Ym9vbGVhbj5cbiAgLy8gc3RhdGljIGVudHJpZXMgZmlsdGVyXG4gIF9iZmxfcz86IGltcG9ydCgnLi4vLi4vbGliL2Jsb29tLWZpbHRlcicpLkJsb29tRmlsdGVyXG4gIC8vIGR5bmFtaWMgZW50aXJlcyBmaWx0ZXJcbiAgX2JmbF9kPzogaW1wb3J0KCcuLi8uLi9saWIvYmxvb20tZmlsdGVyJykuQmxvb21GaWx0ZXJcblxuICBwcml2YXRlIHN0YXRlOiBSZWFkb25seTx7XG4gICAgcm91dGU6IHN0cmluZ1xuICAgIHBhdGhuYW1lOiBzdHJpbmdcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgICBhc1BhdGg6IHN0cmluZ1xuICAgIGxvY2FsZTogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgaXNGYWxsYmFjazogYm9vbGVhblxuICAgIGlzUHJldmlldzogYm9vbGVhblxuICB9PlxuXG4gIHByaXZhdGUgX2tleTogc3RyaW5nID0gY3JlYXRlS2V5KClcblxuICBzdGF0aWMgZXZlbnRzOiBNaXR0RW1pdHRlcjxSb3V0ZXJFdmVudD4gPSBtaXR0KClcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeSxcbiAgICBhczogc3RyaW5nLFxuICAgIHtcbiAgICAgIGluaXRpYWxQcm9wcyxcbiAgICAgIHBhZ2VMb2FkZXIsXG4gICAgICBBcHAsXG4gICAgICB3cmFwQXBwLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgZXJyLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgaXNGYWxsYmFjayxcbiAgICAgIGxvY2FsZSxcbiAgICAgIGxvY2FsZXMsXG4gICAgICBkZWZhdWx0TG9jYWxlLFxuICAgICAgZG9tYWluTG9jYWxlcyxcbiAgICAgIGlzUHJldmlldyxcbiAgICB9OiB7XG4gICAgICBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvblxuICAgICAgaW5pdGlhbFByb3BzOiBhbnlcbiAgICAgIHBhZ2VMb2FkZXI6IGFueVxuICAgICAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gICAgICBBcHA6IEFwcENvbXBvbmVudFxuICAgICAgd3JhcEFwcDogKFdyYXBBcHBDb21wb25lbnQ6IEFwcENvbXBvbmVudCkgPT4gYW55XG4gICAgICBlcnI/OiBFcnJvclxuICAgICAgaXNGYWxsYmFjazogYm9vbGVhblxuICAgICAgbG9jYWxlPzogc3RyaW5nXG4gICAgICBsb2NhbGVzPzogcmVhZG9ubHkgc3RyaW5nW11cbiAgICAgIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgICAgIGRvbWFpbkxvY2FsZXM/OiByZWFkb25seSBEb21haW5Mb2NhbGVbXVxuICAgICAgaXNQcmV2aWV3PzogYm9vbGVhblxuICAgIH1cbiAgKSB7XG4gICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgY29uc3Qgcm91dGUgPSByZW1vdmVUcmFpbGluZ1NsYXNoKHBhdGhuYW1lKVxuXG4gICAgLy8gc2V0IHVwIHRoZSBjb21wb25lbnQgY2FjaGUgKGJ5IHJvdXRlIGtleXMpXG4gICAgdGhpcy5jb21wb25lbnRzID0ge31cbiAgICAvLyBXZSBzaG91bGQgbm90IGtlZXAgdGhlIGNhY2hlLCBpZiB0aGVyZSdzIGFuIGVycm9yXG4gICAgLy8gT3RoZXJ3aXNlLCB0aGlzIGNhdXNlIGlzc3VlcyB3aGVuIHdoZW4gZ29pbmcgYmFjayBhbmRcbiAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgaWYgKHBhdGhuYW1lICE9PSAnL19lcnJvcicpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSB7XG4gICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgZXJyLFxuICAgICAgICBfX05fU1NHOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU0csXG4gICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUCxcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10gPSB7XG4gICAgICBDb21wb25lbnQ6IEFwcCBhcyBDb21wb25lbnRUeXBlLFxuICAgICAgc3R5bGVTaGVldHM6IFtcbiAgICAgICAgLyogL19hcHAgZG9lcyBub3QgbmVlZCBpdHMgc3R5bGVzaGVldHMgbWFuYWdlZCAqL1xuICAgICAgXSxcbiAgICB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyXG4gICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID1cbiAgICAgIGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydFxuXG4gICAgdGhpcy5iYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgJydcbiAgICB0aGlzLnN1YiA9IHN1YnNjcmlwdGlvblxuICAgIHRoaXMuY2xjID0gbnVsbFxuICAgIHRoaXMuX3dyYXBBcHAgPSB3cmFwQXBwXG4gICAgLy8gbWFrZSBzdXJlIHRvIGlnbm9yZSBleHRyYSBwb3BTdGF0ZSBpbiBzYWZhcmkgb24gbmF2aWdhdGluZ1xuICAgIC8vIGJhY2sgZnJvbSBleHRlcm5hbCBzaXRlXG4gICAgdGhpcy5pc1NzciA9IHRydWVcbiAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gZmFsc2VcbiAgICB0aGlzLmlzUmVhZHkgPSAhIShcbiAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5nc3NwIHx8XG4gICAgICBzZWxmLl9fTkVYVF9EQVRBX18uZ2lwIHx8XG4gICAgICBzZWxmLl9fTkVYVF9EQVRBX18uaXNFeHBlcmltZW50YWxDb21waWxlIHx8XG4gICAgICAoc2VsZi5fX05FWFRfREFUQV9fLmFwcEdpcCAmJiAhc2VsZi5fX05FWFRfREFUQV9fLmdzcCkgfHxcbiAgICAgICghYXV0b0V4cG9ydER5bmFtaWMgJiZcbiAgICAgICAgIXNlbGYubG9jYXRpb24uc2VhcmNoICYmXG4gICAgICAgICFwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKVxuICAgIClcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICB0aGlzLmxvY2FsZXMgPSBsb2NhbGVzXG4gICAgICB0aGlzLmRlZmF1bHRMb2NhbGUgPSBkZWZhdWx0TG9jYWxlXG4gICAgICB0aGlzLmRvbWFpbkxvY2FsZXMgPSBkb21haW5Mb2NhbGVzXG4gICAgICB0aGlzLmlzTG9jYWxlRG9tYWluID0gISFkZXRlY3REb21haW5Mb2NhbGUoXG4gICAgICAgIGRvbWFpbkxvY2FsZXMsXG4gICAgICAgIHNlbGYubG9jYXRpb24uaG9zdG5hbWVcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgcm91dGUsXG4gICAgICBwYXRobmFtZSxcbiAgICAgIHF1ZXJ5LFxuICAgICAgYXNQYXRoOiBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lIDogYXMsXG4gICAgICBpc1ByZXZpZXc6ICEhaXNQcmV2aWV3LFxuICAgICAgbG9jYWxlOiBwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUID8gbG9jYWxlIDogdW5kZWZpbmVkLFxuICAgICAgaXNGYWxsYmFjayxcbiAgICB9XG5cbiAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgXCJhc1wiIGRvZXNuJ3Qgc3RhcnQgd2l0aCBkb3VibGUgc2xhc2hlcyBvciBlbHNlIGl0IGNhblxuICAgICAgLy8gdGhyb3cgYW4gZXJyb3IgYXMgaXQncyBjb25zaWRlcmVkIGludmFsaWRcbiAgICAgIGlmICghYXMuc3RhcnRzV2l0aCgnLy8nKSkge1xuICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgY29uc3Qgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7IGxvY2FsZSB9XG4gICAgICAgIGNvbnN0IGFzUGF0aCA9IGdldFVSTCgpXG5cbiAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgIGFzUGF0aCxcbiAgICAgICAgfSkudGhlbigobWF0Y2hlcykgPT4ge1xuICAgICAgICAgIC8vIGlmIG1pZGRsZXdhcmUgbWF0Y2hlcyB3ZSBsZWF2ZSByZXNvbHZpbmcgdG8gdGhlIGNoYW5nZSBmdW5jdGlvblxuICAgICAgICAgIC8vIGFzIHRoZSBzZXJ2ZXIgbmVlZHMgdG8gcmVzb2x2ZSBmb3IgY29ycmVjdCBwcmlvcml0eVxuICAgICAgICAgIDsob3B0aW9ucyBhcyBhbnkpLl9zaG91bGRSZXNvbHZlSHJlZiA9IGFzICE9PSBwYXRobmFtZVxuXG4gICAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICAgICAgbWF0Y2hlc1xuICAgICAgICAgICAgICA/IGFzUGF0aFxuICAgICAgICAgICAgICA6IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksXG4gICAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGFzUGF0aCxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgdGhpcy5vblBvcFN0YXRlKVxuXG4gICAgICAvLyBlbmFibGUgY3VzdG9tIHNjcm9sbCByZXN0b3JhdGlvbiBoYW5kbGluZyB3aGVuIGF2YWlsYWJsZVxuICAgICAgLy8gb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIGJyb3dzZXIncyBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvblBvcFN0YXRlID0gKGU6IFBvcFN0YXRlRXZlbnQpOiB2b2lkID0+IHtcbiAgICBjb25zdCB7IGlzRmlyc3RQb3BTdGF0ZUV2ZW50IH0gPSB0aGlzXG4gICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IGZhbHNlXG5cbiAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGUgYXMgSGlzdG9yeVN0YXRlXG5cbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAvLyBXZSBnZXQgc3RhdGUgYXMgdW5kZWZpbmVkIGZvciB0d28gcmVhc29ucy5cbiAgICAgIC8vICAxLiBXaXRoIG9sZGVyIHNhZmFyaSAoPCA4KSBhbmQgb2xkZXIgY2hyb21lICg8IDM0KVxuICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgLy9cbiAgICAgIC8vIEluIHRoZSBib3RoIGNhc2VzLCB3ZSBkb24ndCBuZWVkIHRvIHByb2NlZWQgYW5kIGNoYW5nZSB0aGUgcm91dGUuXG4gICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAvLyBCdXQgd2UgY2FuIHNpbXBseSByZXBsYWNlIHRoZSBzdGF0ZSB3aXRoIHRoZSBuZXcgY2hhbmdlcy5cbiAgICAgIC8vIEFjdHVhbGx5LCBmb3IgKDEpIHdlIGRvbid0IG5lZWQgdG8gbm90aGluZy4gQnV0IGl0J3MgaGFyZCB0byBkZXRlY3QgdGhhdCBldmVudC5cbiAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnkgfSA9IHRoaXNcbiAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXG4gICAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lOiBhZGRCYXNlUGF0aChwYXRobmFtZSksIHF1ZXJ5IH0pLFxuICAgICAgICBnZXRVUkwoKVxuICAgICAgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gX19OQSBpcyB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBoaXN0b3J5IGVudHJ5IGNhbiBiZSBoYW5kbGVkIGJ5IHRoZSBhcHAtcm91dGVyLlxuICAgIGlmIChzdGF0ZS5fX05BKSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBTYWZhcmkgZmlyZXMgcG9wc3RhdGVldmVudCB3aGVuIHJlb3BlbmluZyB0aGUgYnJvd3Nlci5cbiAgICBpZiAoXG4gICAgICBpc0ZpcnN0UG9wU3RhdGVFdmVudCAmJlxuICAgICAgdGhpcy5sb2NhbGUgPT09IHN0YXRlLm9wdGlvbnMubG9jYWxlICYmXG4gICAgICBzdGF0ZS5hcyA9PT0gdGhpcy5hc1BhdGhcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBmb3JjZWRTY3JvbGw6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSB8IHVuZGVmaW5lZFxuICAgIGNvbnN0IHsgdXJsLCBhcywgb3B0aW9ucywga2V5IH0gPSBzdGF0ZVxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICBpZiAobWFudWFsU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX2tleSAhPT0ga2V5KSB7XG4gICAgICAgICAgLy8gU25hcHNob3QgY3VycmVudCBzY3JvbGwgcG9zaXRpb246XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAgICdfX25leHRfc2Nyb2xsXycgKyB0aGlzLl9rZXksXG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHsgeDogc2VsZi5wYWdlWE9mZnNldCwgeTogc2VsZi5wYWdlWU9mZnNldCB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH0gY2F0Y2gge31cblxuICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oJ19fbmV4dF9zY3JvbGxfJyArIGtleSlcbiAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IEpTT04ucGFyc2UodiEpXG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSB7IHg6IDAsIHk6IDAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9rZXkgPSBrZXlcblxuICAgIGNvbnN0IHsgcGF0aG5hbWUgfSA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGRvbid0IHJlLXJlbmRlciBvbiBpbml0aWFsIGxvYWQsXG4gICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgaWYgKFxuICAgICAgdGhpcy5pc1NzciAmJlxuICAgICAgYXMgPT09IGFkZEJhc2VQYXRoKHRoaXMuYXNQYXRoKSAmJlxuICAgICAgcGF0aG5hbWUgPT09IGFkZEJhc2VQYXRoKHRoaXMucGF0aG5hbWUpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLmNoYW5nZShcbiAgICAgICdyZXBsYWNlU3RhdGUnLFxuICAgICAgdXJsLFxuICAgICAgYXMsXG4gICAgICBPYmplY3QuYXNzaWduPHt9LCBUcmFuc2l0aW9uT3B0aW9ucywgVHJhbnNpdGlvbk9wdGlvbnM+KHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICBsb2NhbGU6IG9wdGlvbnMubG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBpbnRlcm5hbCB2YWx1ZSBub3QgZXhwb3NlZCBvbiB0eXBlc1xuICAgICAgICBfaDogMCxcbiAgICAgIH0pLFxuICAgICAgZm9yY2VkU2Nyb2xsXG4gICAgKVxuICB9XG5cbiAgcmVsb2FkKCk6IHZvaWQge1xuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdvIGJhY2sgaW4gaGlzdG9yeVxuICAgKi9cbiAgYmFjaygpIHtcbiAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBmb3J3YXJkIGluIGhpc3RvcnlcbiAgICovXG4gIGZvcndhcmQoKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuZm9yd2FyZCgpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHB1c2godXJsOiBVcmwsIGFzPzogVXJsLCBvcHRpb25zOiBUcmFuc2l0aW9uT3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04pIHtcbiAgICAgIC8vIFRPRE86IHJlbW92ZSBpbiB0aGUgZnV0dXJlIHdoZW4gd2UgdXBkYXRlIGhpc3RvcnkgYmVmb3JlIHJvdXRlIGNoYW5nZVxuICAgICAgLy8gaXMgY29tcGxldGUsIGFzIHRoZSBwb3BzdGF0ZSBldmVudCBzaG91bGQgaGFuZGxlIHRoaXMgY2FwdHVyZS5cbiAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFNuYXBzaG90IHNjcm9sbCBwb3NpdGlvbiByaWdodCBiZWZvcmUgbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlOlxuICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXG4gICAgICAgICAgICAnX19uZXh0X3Njcm9sbF8nICsgdGhpcy5fa2V5LFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoeyB4OiBzZWxmLnBhZ2VYT2Zmc2V0LCB5OiBzZWxmLnBhZ2VZT2Zmc2V0IH0pXG4gICAgICAgICAgKVxuICAgICAgICB9IGNhdGNoIHt9XG4gICAgICB9XG4gICAgfVxuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdwdXNoU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHJlcGxhY2VTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqL1xuICByZXBsYWNlKHVybDogVXJsLCBhcz86IFVybCwgb3B0aW9uczogVHJhbnNpdGlvbk9wdGlvbnMgPSB7fSkge1xuICAgIDsoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpXG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgYXN5bmMgX2JmbChcbiAgICBhczogc3RyaW5nLFxuICAgIHJlc29sdmVkQXM/OiBzdHJpbmcsXG4gICAgbG9jYWxlPzogc3RyaW5nIHwgZmFsc2UsXG4gICAgc2tpcE5hdmlnYXRlPzogYm9vbGVhblxuICApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgIGlmICghdGhpcy5fYmZsX3MgJiYgIXRoaXMuX2JmbF9kKSB7XG4gICAgICAgIGNvbnN0IHsgQmxvb21GaWx0ZXIgfSA9XG4gICAgICAgICAgcmVxdWlyZSgnLi4vLi4vbGliL2Jsb29tLWZpbHRlcicpIGFzIHR5cGVvZiBpbXBvcnQoJy4uLy4uL2xpYi9ibG9vbS1maWx0ZXInKVxuXG4gICAgICAgIHR5cGUgRmlsdGVyID0gUmV0dXJuVHlwZTxcbiAgICAgICAgICBpbXBvcnQoJy4uLy4uL2xpYi9ibG9vbS1maWx0ZXInKS5CbG9vbUZpbHRlclsnZXhwb3J0J11cbiAgICAgICAgPlxuICAgICAgICBsZXQgc3RhdGljRmlsdGVyRGF0YTogRmlsdGVyIHwgdW5kZWZpbmVkXG4gICAgICAgIGxldCBkeW5hbWljRmlsdGVyRGF0YTogRmlsdGVyIHwgdW5kZWZpbmVkXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICA7KHtcbiAgICAgICAgICAgIF9fcm91dGVyRmlsdGVyU3RhdGljOiBzdGF0aWNGaWx0ZXJEYXRhLFxuICAgICAgICAgICAgX19yb3V0ZXJGaWx0ZXJEeW5hbWljOiBkeW5hbWljRmlsdGVyRGF0YSxcbiAgICAgICAgICB9ID0gKGF3YWl0IGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSkgYXMgYW55IGFzIHtcbiAgICAgICAgICAgIF9fcm91dGVyRmlsdGVyU3RhdGljPzogRmlsdGVyXG4gICAgICAgICAgICBfX3JvdXRlckZpbHRlckR5bmFtaWM/OiBGaWx0ZXJcbiAgICAgICAgICB9KVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAvLyBmYWlsZWQgdG8gbG9hZCBidWlsZCBtYW5pZmVzdCBoYXJkIG5hdmlnYXRlXG4gICAgICAgICAgLy8gdG8gYmUgc2FmZVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICAgIGlmIChza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgIHVybDogYWRkQmFzZVBhdGgoXG4gICAgICAgICAgICAgIGFkZExvY2FsZShhcywgbG9jYWxlIHx8IHRoaXMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgcm91dGVyRmlsdGVyU1ZhbHVlOiBGaWx0ZXIgfCBmYWxzZSA9IHByb2Nlc3MuZW52XG4gICAgICAgICAgLl9fTkVYVF9DTElFTlRfUk9VVEVSX1NfRklMVEVSIGFzIGFueVxuXG4gICAgICAgIGlmICghc3RhdGljRmlsdGVyRGF0YSAmJiByb3V0ZXJGaWx0ZXJTVmFsdWUpIHtcbiAgICAgICAgICBzdGF0aWNGaWx0ZXJEYXRhID0gcm91dGVyRmlsdGVyU1ZhbHVlID8gcm91dGVyRmlsdGVyU1ZhbHVlIDogdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByb3V0ZXJGaWx0ZXJEVmFsdWU6IEZpbHRlciB8IGZhbHNlID0gcHJvY2Vzcy5lbnZcbiAgICAgICAgICAuX19ORVhUX0NMSUVOVF9ST1VURVJfRF9GSUxURVIgYXMgYW55XG5cbiAgICAgICAgaWYgKCFkeW5hbWljRmlsdGVyRGF0YSAmJiByb3V0ZXJGaWx0ZXJEVmFsdWUpIHtcbiAgICAgICAgICBkeW5hbWljRmlsdGVyRGF0YSA9IHJvdXRlckZpbHRlckRWYWx1ZVxuICAgICAgICAgICAgPyByb3V0ZXJGaWx0ZXJEVmFsdWVcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGljRmlsdGVyRGF0YT8ubnVtSGFzaGVzKSB7XG4gICAgICAgICAgdGhpcy5fYmZsX3MgPSBuZXcgQmxvb21GaWx0ZXIoXG4gICAgICAgICAgICBzdGF0aWNGaWx0ZXJEYXRhLm51bUl0ZW1zLFxuICAgICAgICAgICAgc3RhdGljRmlsdGVyRGF0YS5lcnJvclJhdGVcbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5fYmZsX3MuaW1wb3J0KHN0YXRpY0ZpbHRlckRhdGEpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHluYW1pY0ZpbHRlckRhdGE/Lm51bUhhc2hlcykge1xuICAgICAgICAgIHRoaXMuX2JmbF9kID0gbmV3IEJsb29tRmlsdGVyKFxuICAgICAgICAgICAgZHluYW1pY0ZpbHRlckRhdGEubnVtSXRlbXMsXG4gICAgICAgICAgICBkeW5hbWljRmlsdGVyRGF0YS5lcnJvclJhdGVcbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5fYmZsX2QuaW1wb3J0KGR5bmFtaWNGaWx0ZXJEYXRhKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBtYXRjaGVzQmZsU3RhdGljID0gZmFsc2VcbiAgICAgIGxldCBtYXRjaGVzQmZsRHluYW1pYyA9IGZhbHNlXG4gICAgICBjb25zdCBwYXRoc1RvQ2hlY2s6IEFycmF5PHsgYXM/OiBzdHJpbmc7IGFsbG93TWF0Y2hDdXJyZW50PzogYm9vbGVhbiB9PiA9XG4gICAgICAgIFt7IGFzIH0sIHsgYXM6IHJlc29sdmVkQXMgfV1cblxuICAgICAgZm9yIChjb25zdCB7IGFzOiBjdXJBcywgYWxsb3dNYXRjaEN1cnJlbnQgfSBvZiBwYXRoc1RvQ2hlY2spIHtcbiAgICAgICAgaWYgKGN1ckFzKSB7XG4gICAgICAgICAgY29uc3QgYXNOb1NsYXNoID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChcbiAgICAgICAgICAgIG5ldyBVUkwoY3VyQXMsICdodHRwOi8vbicpLnBhdGhuYW1lXG4gICAgICAgICAgKVxuICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaExvY2FsZSA9IGFkZEJhc2VQYXRoKFxuICAgICAgICAgICAgYWRkTG9jYWxlKGFzTm9TbGFzaCwgbG9jYWxlIHx8IHRoaXMubG9jYWxlKVxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGFsbG93TWF0Y2hDdXJyZW50IHx8XG4gICAgICAgICAgICBhc05vU2xhc2ggIT09XG4gICAgICAgICAgICAgIHJlbW92ZVRyYWlsaW5nU2xhc2gobmV3IFVSTCh0aGlzLmFzUGF0aCwgJ2h0dHA6Ly9uJykucGF0aG5hbWUpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBtYXRjaGVzQmZsU3RhdGljID1cbiAgICAgICAgICAgICAgbWF0Y2hlc0JmbFN0YXRpYyB8fFxuICAgICAgICAgICAgICAhIXRoaXMuX2JmbF9zPy5jb250YWlucyhhc05vU2xhc2gpIHx8XG4gICAgICAgICAgICAgICEhdGhpcy5fYmZsX3M/LmNvbnRhaW5zKGFzTm9TbGFzaExvY2FsZSlcblxuICAgICAgICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkQVMgb2YgW2FzTm9TbGFzaCwgYXNOb1NsYXNoTG9jYWxlXSkge1xuICAgICAgICAgICAgICAvLyBpZiBhbnkgc3ViLXBhdGggb2YgYXMgbWF0Y2hlcyBhIGR5bmFtaWMgZmlsdGVyIHBhdGhcbiAgICAgICAgICAgICAgLy8gaXQgc2hvdWxkIGJlIGhhcmQgbmF2aWdhdGVkXG4gICAgICAgICAgICAgIGNvbnN0IGN1ckFzUGFydHMgPSBub3JtYWxpemVkQVMuc3BsaXQoJy8nKVxuICAgICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAhbWF0Y2hlc0JmbER5bmFtaWMgJiYgaSA8IGN1ckFzUGFydHMubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBpKytcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBhcnQgPSBjdXJBc1BhcnRzLnNsaWNlKDAsIGkpLmpvaW4oJy8nKVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFydCAmJiB0aGlzLl9iZmxfZD8uY29udGFpbnMoY3VycmVudFBhcnQpKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaGVzQmZsRHluYW1pYyA9IHRydWVcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBjbGllbnQgcm91dGVyIGZpbHRlciBpcyBtYXRjaGVkIHRoZW4gd2UgdHJpZ2dlclxuICAgICAgICAgICAgLy8gYSBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgICAgIGlmIChtYXRjaGVzQmZsU3RhdGljIHx8IG1hdGNoZXNCZmxEeW5hbWljKSB7XG4gICAgICAgICAgICAgIGlmIChza2lwTmF2aWdhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFkZEJhc2VQYXRoKFxuICAgICAgICAgICAgICAgICAgYWRkTG9jYWxlKGFzLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUsIHRoaXMuZGVmYXVsdExvY2FsZSlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY2hhbmdlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zLFxuICAgIGZvcmNlZFNjcm9sbD86IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVxuICApOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBpZiAoIWlzTG9jYWxVUkwodXJsKSkge1xuICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmwsIHJvdXRlcjogdGhpcyB9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAvLyBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LiBJdCBtYXkgY2hhbmdlIGF0XG4gICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgY29uc3QgaXNRdWVyeVVwZGF0aW5nID0gKG9wdGlvbnMgYXMgYW55KS5faCA9PT0gMVxuXG4gICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgYXdhaXQgdGhpcy5fYmZsKGFzLCB1bmRlZmluZWQsIG9wdGlvbnMubG9jYWxlKVxuICAgIH1cblxuICAgIGxldCBzaG91bGRSZXNvbHZlSHJlZiA9XG4gICAgICBpc1F1ZXJ5VXBkYXRpbmcgfHxcbiAgICAgIChvcHRpb25zIGFzIGFueSkuX3Nob3VsZFJlc29sdmVIcmVmIHx8XG4gICAgICBwYXJzZVBhdGgodXJsKS5wYXRobmFtZSA9PT0gcGFyc2VQYXRoKGFzKS5wYXRobmFtZVxuXG4gICAgY29uc3QgbmV4dFN0YXRlID0ge1xuICAgICAgLi4udGhpcy5zdGF0ZSxcbiAgICB9XG5cbiAgICAvLyBmb3Igc3RhdGljIHBhZ2VzIHdpdGggcXVlcnkgcGFyYW1zIGluIHRoZSBVUkwgd2UgZGVsYXlcbiAgICAvLyBtYXJraW5nIHRoZSByb3V0ZXIgcmVhZHkgdW50aWwgYWZ0ZXIgdGhlIHF1ZXJ5IGlzIHVwZGF0ZWRcbiAgICAvLyBvciBhIG5hdmlnYXRpb24gaGFzIG9jY3VycmVkXG4gICAgY29uc3QgcmVhZHlTdGF0ZUNoYW5nZSA9IHRoaXMuaXNSZWFkeSAhPT0gdHJ1ZVxuICAgIHRoaXMuaXNSZWFkeSA9IHRydWVcbiAgICBjb25zdCBpc1NzciA9IHRoaXMuaXNTc3JcblxuICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICB0aGlzLmlzU3NyID0gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBpZiBhIHJvdXRlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBiZWZvcmVcbiAgICAvLyB0aGUgcXVlcnkgdXBkYXRpbmcgaXMgdHJpZ2dlcmVkIGlnbm9yZSBxdWVyeSB1cGRhdGluZ1xuICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5jbGMpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IHByZXZMb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlXG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9XG4gICAgICAgIG9wdGlvbnMubG9jYWxlID09PSBmYWxzZVxuICAgICAgICAgID8gdGhpcy5kZWZhdWx0TG9jYWxlXG4gICAgICAgICAgOiBvcHRpb25zLmxvY2FsZSB8fCBuZXh0U3RhdGUubG9jYWxlXG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gbmV4dFN0YXRlLmxvY2FsZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoXG4gICAgICAgIGhhc0Jhc2VQYXRoKGFzKSA/IHJlbW92ZUJhc2VQYXRoKGFzKSA6IGFzXG4gICAgICApXG4gICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aChcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgIHRoaXMubG9jYWxlc1xuICAgICAgKVxuXG4gICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZVxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZEJhc2VQYXRoKHBhcnNlZEFzLnBhdGhuYW1lKVxuICAgICAgICBhcyA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKVxuICAgICAgICB1cmwgPSBhZGRCYXNlUGF0aChcbiAgICAgICAgICBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICAgICAgaGFzQmFzZVBhdGgodXJsKSA/IHJlbW92ZUJhc2VQYXRoKHVybCkgOiB1cmwsXG4gICAgICAgICAgICB0aGlzLmxvY2FsZXNcbiAgICAgICAgICApLnBhdGhuYW1lXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGxldCBkaWROYXZpZ2F0ZSA9IGZhbHNlXG5cbiAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAvLyBpZiB0aGUgbG9jYWxlIGlzbid0IGNvbmZpZ3VyZWQgaGFyZCBuYXZpZ2F0ZSB0byBzaG93IDQwNCBwYWdlXG4gICAgICAgIGlmICghdGhpcy5sb2NhbGVzPy5pbmNsdWRlcyhuZXh0U3RhdGUubG9jYWxlISkpIHtcbiAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGFkZExvY2FsZShwYXJzZWRBcy5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSlcbiAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICB1cmw6IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZEFzKSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC8vIHRoaXMgd2FzIHByZXZpb3VzbHkgYSByZXR1cm4gYnV0IHdhcyByZW1vdmVkIGluIGZhdm9yXG4gICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICBkaWROYXZpZ2F0ZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgdGhpcy5kb21haW5Mb2NhbGVzLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIG5leHRTdGF0ZS5sb2NhbGVcbiAgICAgIClcblxuICAgICAgLy8gd2UgbmVlZCB0byB3cmFwIHRoaXMgaW4gdGhlIGVudiBjaGVjayBhZ2FpbiBzaW5jZSByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAvLyBtb3ZlcyB0aGlzIG9uIGl0cyBvd24gZHVlIHRvIHRoZSByZXR1cm5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBuYXZpZ2F0aW5nIHRvIGEgZG9tYWluIGxvY2FsZSBlbnN1cmUgd2UgcmVkaXJlY3QgdG8gdGhlXG4gICAgICAgIC8vIGNvcnJlY3QgZG9tYWluXG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZGlkTmF2aWdhdGUgJiZcbiAgICAgICAgICBkZXRlY3RlZERvbWFpbiAmJlxuICAgICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gJiZcbiAgICAgICAgICBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lICE9PSBkZXRlY3RlZERvbWFpbi5kb21haW5cbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgYXNOb0Jhc2VQYXRoID0gcmVtb3ZlQmFzZVBhdGgoYXMpXG4gICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgdXJsOiBgaHR0cCR7ZGV0ZWN0ZWREb21haW4uaHR0cCA/ICcnIDogJ3MnfTovLyR7XG4gICAgICAgICAgICAgIGRldGVjdGVkRG9tYWluLmRvbWFpblxuICAgICAgICAgICAgfSR7YWRkQmFzZVBhdGgoXG4gICAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGUgPT09IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICAgIDogYC8ke25leHRTdGF0ZS5sb2NhbGV9YFxuICAgICAgICAgICAgICB9JHthc05vQmFzZVBhdGggPT09ICcvJyA/ICcnIDogYXNOb0Jhc2VQYXRofWAgfHwgJy8nXG4gICAgICAgICAgICApfWAsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyB0aGlzIHdhcyBwcmV2aW91c2x5IGEgcmV0dXJuIGJ1dCB3YXMgcmVtb3ZlZCBpbiBmYXZvclxuICAgICAgICAgIC8vIG9mIGJldHRlciBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2l0aCByZWdlbmVyYXRvciBydW50aW1lXG4gICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRpZE5hdmlnYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgaWYgKFNUKSB7XG4gICAgICBwZXJmb3JtYW5jZS5tYXJrKCdyb3V0ZUNoYW5nZScpXG4gICAgfVxuXG4gICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UsIHNjcm9sbCA9IHRydWUgfSA9IG9wdGlvbnNcbiAgICBjb25zdCByb3V0ZVByb3BzID0geyBzaGFsbG93IH1cblxuICAgIGlmICh0aGlzLl9pbkZsaWdodFJvdXRlICYmIHRoaXMuY2xjKSB7XG4gICAgICBpZiAoIWlzU3NyKSB7XG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcbiAgICAgICAgICAncm91dGVDaGFuZ2VFcnJvcicsXG4gICAgICAgICAgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLFxuICAgICAgICAgIHRoaXMuX2luRmxpZ2h0Um91dGUsXG4gICAgICAgICAgcm91dGVQcm9wc1xuICAgICAgICApXG4gICAgICB9XG4gICAgICB0aGlzLmNsYygpXG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG5cbiAgICBhcyA9IGFkZEJhc2VQYXRoKFxuICAgICAgYWRkTG9jYWxlKFxuICAgICAgICBoYXNCYXNlUGF0aChhcykgPyByZW1vdmVCYXNlUGF0aChhcykgOiBhcyxcbiAgICAgICAgb3B0aW9ucy5sb2NhbGUsXG4gICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgKVxuICAgIClcbiAgICBjb25zdCBjbGVhbmVkQXMgPSByZW1vdmVMb2NhbGUoXG4gICAgICBoYXNCYXNlUGF0aChhcykgPyByZW1vdmVCYXNlUGF0aChhcykgOiBhcyxcbiAgICAgIG5leHRTdGF0ZS5sb2NhbGVcbiAgICApXG4gICAgdGhpcy5faW5GbGlnaHRSb3V0ZSA9IGFzXG5cbiAgICBjb25zdCBsb2NhbGVDaGFuZ2UgPSBwcmV2TG9jYWxlICE9PSBuZXh0U3RhdGUubG9jYWxlXG5cbiAgICAvLyBJZiB0aGUgdXJsIGNoYW5nZSBpcyBvbmx5IHJlbGF0ZWQgdG8gYSBoYXNoIGNoYW5nZVxuICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cblxuICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgbmV4dFN0YXRlLmFzUGF0aCA9IGNsZWFuZWRBc1xuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcylcbiAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICBzY3JvbGw6IGZhbHNlLFxuICAgICAgfSlcbiAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKVxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5zZXQobmV4dFN0YXRlLCB0aGlzLmNvbXBvbmVudHNbbmV4dFN0YXRlLnJvdXRlXSwgbnVsbClcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoaXNFcnJvcihlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGNsZWFuZWRBcywgcm91dGVQcm9wcylcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cblxuICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcywgcm91dGVQcm9wcylcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgbGV0IHBhcnNlZCA9IHBhcnNlUmVsYXRpdmVVcmwodXJsKVxuICAgIGxldCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gcGFyc2VkXG5cbiAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgLy8gZ2V0IHRoZWlyIHF1ZXJ5IHBhcmFtZXRlcnMgdG8gYWxsb3cgZW5zdXJpbmcgdGhleSBjYW4gYmUgcGFyc2VkIHByb3Blcmx5XG4gICAgLy8gd2hlbiByZXdyaXR0ZW4gdG9cbiAgICBsZXQgcGFnZXM6IHN0cmluZ1tdLCByZXdyaXRlczogYW55XG4gICAgdHJ5IHtcbiAgICAgIDtbcGFnZXMsIHsgX19yZXdyaXRlczogcmV3cml0ZXMgfV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCksXG4gICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCksXG4gICAgICBdKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWYgd2UgZmFpbCB0byByZXNvbHZlIHRoZSBwYWdlIGxpc3Qgb3IgY2xpZW50LWJ1aWxkIG1hbmlmZXN0LCB3ZSBtdXN0XG4gICAgICAvLyBkbyBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb246XG4gICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybDogYXMsIHJvdXRlcjogdGhpcyB9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAvLyAobm90IGxvY2F0aW9uLnJlbG9hZCgpIGJ1dCByZWxvYWQgZ2V0SW5pdGlhbFByb3BzIGFuZCBvdGhlciBOZXh0LmpzIHN0dWZmcylcbiAgICAvLyBXZSBhbHNvIG5lZWQgdG8gc2V0IHRoZSBtZXRob2QgPSByZXBsYWNlU3RhdGUgYWx3YXlzXG4gICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAvLyBXZSBzaG91bGQgY29tcGFyZSB0aGUgbmV3IGFzUGF0aCB0byB0aGUgY3VycmVudCBhc1BhdGgsIG5vdCB0aGUgdXJsXG4gICAgaWYgKCF0aGlzLnVybElzTmV3KGNsZWFuZWRBcykgJiYgIWxvY2FsZUNoYW5nZSkge1xuICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSdcbiAgICB9XG5cbiAgICAvLyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGFzIHZhbHVlIHVzaW5nIHJld3JpdGVzIGZvciBkeW5hbWljIFNTR1xuICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICBsZXQgcmVzb2x2ZWRBcyA9IGFzXG5cbiAgICAvLyB1cmwgYW5kIGFzIHNob3VsZCBhbHdheXMgYmUgcHJlZml4ZWQgd2l0aCBiYXNlUGF0aCBieSB0aGlzXG4gICAgLy8gcG9pbnQgYnkgZWl0aGVyIG5leHQvbGluayBvciByb3V0ZXIucHVzaC9yZXBsYWNlIHNvIHN0cmlwIHRoZVxuICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgcGF0aG5hbWUgPSBwYXRobmFtZVxuICAgICAgPyByZW1vdmVUcmFpbGluZ1NsYXNoKHJlbW92ZUJhc2VQYXRoKHBhdGhuYW1lKSlcbiAgICAgIDogcGF0aG5hbWVcblxuICAgIGxldCByb3V0ZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG4gICAgY29uc3QgcGFyc2VkQXNQYXRobmFtZSA9IGFzLnN0YXJ0c1dpdGgoJy8nKSAmJiBwYXJzZVJlbGF0aXZlVXJsKGFzKS5wYXRobmFtZVxuXG4gICAgLy8gaWYgd2UgZGV0ZWN0ZWQgdGhlIHBhdGggYXMgYXBwIHJvdXRlIGR1cmluZyBwcmVmZXRjaGluZ1xuICAgIC8vIHRyaWdnZXIgaGFyZCBuYXZpZ2F0aW9uXG4gICAgaWYgKCh0aGlzLmNvbXBvbmVudHNbcGF0aG5hbWVdIGFzIGFueSk/Ll9fYXBwUm91dGVyKSB7XG4gICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybDogYXMsIHJvdXRlcjogdGhpcyB9KVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpID0+IHt9KVxuICAgIH1cblxuICAgIGNvbnN0IGlzTWlkZGxld2FyZVJld3JpdGUgPSAhIShcbiAgICAgIHBhcnNlZEFzUGF0aG5hbWUgJiZcbiAgICAgIHJvdXRlICE9PSBwYXJzZWRBc1BhdGhuYW1lICYmXG4gICAgICAoIWlzRHluYW1pY1JvdXRlKHJvdXRlKSB8fFxuICAgICAgICAhZ2V0Um91dGVNYXRjaGVyKGdldFJvdXRlUmVnZXgocm91dGUpKShwYXJzZWRBc1BhdGhuYW1lKSlcbiAgICApXG5cbiAgICAvLyB3ZSBkb24ndCBhdHRlbXB0IHJlc29sdmUgYXNQYXRoIHdoZW4gd2UgbmVlZCB0byBleGVjdXRlXG4gICAgLy8gbWlkZGxld2FyZSBhcyB0aGUgcmVzb2x2aW5nIHdpbGwgb2NjdXIgc2VydmVyLXNpZGVcbiAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9XG4gICAgICAhb3B0aW9ucy5zaGFsbG93ICYmXG4gICAgICAoYXdhaXQgbWF0Y2hlc01pZGRsZXdhcmUoe1xuICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgIH0pKVxuXG4gICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiBpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgc2hvdWxkUmVzb2x2ZUhyZWYgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmIChzaG91bGRSZXNvbHZlSHJlZiAmJiBwYXRobmFtZSAhPT0gJy9fZXJyb3InKSB7XG4gICAgICA7KG9wdGlvbnMgYXMgYW55KS5fc2hvdWxkUmVzb2x2ZUhyZWYgPSB0cnVlXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9IHJlc29sdmVSZXdyaXRlcyhcbiAgICAgICAgICBhZGRCYXNlUGF0aChhZGRMb2NhbGUoY2xlYW5lZEFzLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSksXG4gICAgICAgICAgcGFnZXMsXG4gICAgICAgICAgcmV3cml0ZXMsXG4gICAgICAgICAgcXVlcnksXG4gICAgICAgICAgKHA6IHN0cmluZykgPT4gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksXG4gICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgIClcblxuICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XG4gICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmw6IGFzLCByb3V0ZXI6IHRoaXMgfSlcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBkaXJlY3RseSBtYXRjaGVzIGEgcGFnZSB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgaHJlZiB0b1xuICAgICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWZcbiAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXRobmFtZSlcblxuICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKVxuXG4gICAgICAgIGlmIChwYXJzZWQucGF0aG5hbWUgIT09IHBhdGhuYW1lKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBhZGRCYXNlUGF0aChwYXRobmFtZSlcblxuICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzTG9jYWxVUkwoYXMpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEludmFsaWQgaHJlZjogXCIke3VybH1cIiBhbmQgYXM6IFwiJHthc31cIiwgcmVjZWl2ZWQgcmVsYXRpdmUgaHJlZiBhbmQgZXh0ZXJuYWwgYXNgICtcbiAgICAgICAgICAgIGBcXG5TZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9pbnZhbGlkLXJlbGF0aXZlLXVybC1leHRlcm5hbC1hc2BcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmw6IGFzLCByb3V0ZXI6IHRoaXMgfSlcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJlc29sdmVkQXMgPSByZW1vdmVMb2NhbGUocmVtb3ZlQmFzZVBhdGgocmVzb2x2ZWRBcyksIG5leHRTdGF0ZS5sb2NhbGUpXG5cbiAgICByb3V0ZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2gocGF0aG5hbWUpXG4gICAgbGV0IHJvdXRlTWF0Y2g6IFBhcmFtcyB8IGZhbHNlID0gZmFsc2VcblxuICAgIGlmIChpc0R5bmFtaWNSb3V0ZShyb3V0ZSkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZEFzID0gcGFyc2VSZWxhdGl2ZVVybChyZXNvbHZlZEFzKVxuICAgICAgY29uc3QgYXNQYXRobmFtZSA9IHBhcnNlZEFzLnBhdGhuYW1lXG5cbiAgICAgIGNvbnN0IHJvdXRlUmVnZXggPSBnZXRSb3V0ZVJlZ2V4KHJvdXRlKVxuICAgICAgcm91dGVNYXRjaCA9IGdldFJvdXRlTWF0Y2hlcihyb3V0ZVJlZ2V4KShhc1BhdGhuYW1lKVxuICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZVxuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkQXMgPSBzaG91bGRJbnRlcnBvbGF0ZVxuICAgICAgICA/IGludGVycG9sYXRlQXMocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KVxuICAgICAgICA6ICh7fSBhcyB7IHJlc3VsdDogdW5kZWZpbmVkOyBwYXJhbXM6IHVuZGVmaW5lZCB9KVxuXG4gICAgICBpZiAoIXJvdXRlTWF0Y2ggfHwgKHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpKSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmdQYXJhbXMgPSBPYmplY3Qua2V5cyhyb3V0ZVJlZ2V4Lmdyb3VwcykuZmlsdGVyKFxuICAgICAgICAgIChwYXJhbSkgPT4gIXF1ZXJ5W3BhcmFtXSAmJiAhcm91dGVSZWdleC5ncm91cHNbcGFyYW1dLm9wdGlvbmFsXG4gICAgICAgIClcblxuICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwICYmICFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGAke1xuICAgICAgICAgICAgICAgIHNob3VsZEludGVycG9sYXRlXG4gICAgICAgICAgICAgICAgICA/IGBJbnRlcnBvbGF0aW5nIGhyZWZgXG4gICAgICAgICAgICAgICAgICA6IGBNaXNtYXRjaGluZyBcXGBhc1xcYCBhbmQgXFxgaHJlZlxcYGBcbiAgICAgICAgICAgICAgfSBmYWlsZWQgdG8gbWFudWFsbHkgcHJvdmlkZSBgICtcbiAgICAgICAgICAgICAgICBgdGhlIHBhcmFtczogJHttaXNzaW5nUGFyYW1zLmpvaW4oXG4gICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgKX0gaW4gdGhlIFxcYGhyZWZcXGAncyBcXGBxdWVyeVxcYGBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAoc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgPyBgVGhlIHByb3ZpZGVkIFxcYGhyZWZcXGAgKCR7dXJsfSkgdmFsdWUgaXMgbWlzc2luZyBxdWVyeSB2YWx1ZXMgKCR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgJywgJ1xuICAgICAgICAgICAgICAgICl9KSB0byBiZSBpbnRlcnBvbGF0ZWQgcHJvcGVybHkuIGBcbiAgICAgICAgICAgICAgOiBgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgKSArXG4gICAgICAgICAgICAgIGBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzLyR7XG4gICAgICAgICAgICAgICAgc2hvdWxkSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgID8gJ2hyZWYtaW50ZXJwb2xhdGlvbi1mYWlsZWQnXG4gICAgICAgICAgICAgICAgICA6ICdpbmNvbXBhdGlibGUtaHJlZi1hcydcbiAgICAgICAgICAgICAgfWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgYXMgPSBmb3JtYXRXaXRoVmFsaWRhdGlvbihcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGludGVycG9sYXRlZEFzLnJlc3VsdCxcbiAgICAgICAgICAgIHF1ZXJ5OiBvbWl0KHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMhKSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCByb3V0ZU1hdGNoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBhcywgcm91dGVQcm9wcylcbiAgICB9XG5cbiAgICBjb25zdCBpc0Vycm9yUm91dGUgPSB0aGlzLnBhdGhuYW1lID09PSAnLzQwNCcgfHwgdGhpcy5wYXRobmFtZSA9PT0gJy9fZXJyb3InXG5cbiAgICB0cnkge1xuICAgICAgbGV0IHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgcm91dGUsXG4gICAgICAgIHBhdGhuYW1lLFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgYXMsXG4gICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgIHJvdXRlUHJvcHMsXG4gICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICBoYXNNaWRkbGV3YXJlOiBpc01pZGRsZXdhcmVNYXRjaCxcbiAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbiAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFjayxcbiAgICAgICAgaXNNaWRkbGV3YXJlUmV3cml0ZSxcbiAgICAgIH0pXG5cbiAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5fYmZsKFxuICAgICAgICAgIGFzLFxuICAgICAgICAgICdyZXNvbHZlZEFzJyBpbiByb3V0ZUluZm8gPyByb3V0ZUluZm8ucmVzb2x2ZWRBcyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKCdyb3V0ZScgaW4gcm91dGVJbmZvICYmIGlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgIHBhdGhuYW1lID0gcm91dGVJbmZvLnJvdXRlIHx8IHJvdXRlXG4gICAgICAgIHJvdXRlID0gcGF0aG5hbWVcblxuICAgICAgICBpZiAoIXJvdXRlUHJvcHMuc2hhbGxvdykge1xuICAgICAgICAgIHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGVJbmZvLnF1ZXJ5IHx8IHt9LCBxdWVyeSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsZWFuZWRQYXJzZWRQYXRobmFtZSA9IGhhc0Jhc2VQYXRoKHBhcnNlZC5wYXRobmFtZSlcbiAgICAgICAgICA/IHJlbW92ZUJhc2VQYXRoKHBhcnNlZC5wYXRobmFtZSlcbiAgICAgICAgICA6IHBhcnNlZC5wYXRobmFtZVxuXG4gICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHBhdGhuYW1lICE9PSBjbGVhbmVkUGFyc2VkUGF0aG5hbWUpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhyb3V0ZU1hdGNoKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHF1ZXJ5W2tleV0gPT09IHJvdXRlTWF0Y2hba2V5XSkge1xuICAgICAgICAgICAgICBkZWxldGUgcXVlcnlba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEeW5hbWljUm91dGUocGF0aG5hbWUpKSB7XG4gICAgICAgICAgY29uc3QgcHJlZml4ZWRBcyA9XG4gICAgICAgICAgICAhcm91dGVQcm9wcy5zaGFsbG93ICYmIHJvdXRlSW5mby5yZXNvbHZlZEFzXG4gICAgICAgICAgICAgID8gcm91dGVJbmZvLnJlc29sdmVkQXNcbiAgICAgICAgICAgICAgOiBhZGRCYXNlUGF0aChcbiAgICAgICAgICAgICAgICAgIGFkZExvY2FsZShcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChhcywgbG9jYXRpb24uaHJlZikucGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5sb2NhbGVcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgbGV0IHJld3JpdGVBcyA9IHByZWZpeGVkQXNcblxuICAgICAgICAgIGlmIChoYXNCYXNlUGF0aChyZXdyaXRlQXMpKSB7XG4gICAgICAgICAgICByZXdyaXRlQXMgPSByZW1vdmVCYXNlUGF0aChyZXdyaXRlQXMpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsZVJlc3VsdCA9IG5vcm1hbGl6ZUxvY2FsZVBhdGgocmV3cml0ZUFzLCB0aGlzLmxvY2FsZXMpXG4gICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGVcbiAgICAgICAgICAgIHJld3JpdGVBcyA9IGxvY2FsZVJlc3VsdC5wYXRobmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gZ2V0Um91dGVSZWdleChwYXRobmFtZSlcbiAgICAgICAgICBjb25zdCBjdXJSb3V0ZU1hdGNoID0gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXgpKFxuICAgICAgICAgICAgbmV3IFVSTChyZXdyaXRlQXMsIGxvY2F0aW9uLmhyZWYpLnBhdGhuYW1lXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgaWYgKGN1clJvdXRlTWF0Y2gpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIGN1clJvdXRlTWF0Y2gpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSByb3V0ZUluZm8gYnJpbmdzIGEgcmVkaXJlY3Qgd2Ugc2ltcGx5IGFwcGx5IGl0LlxuICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgaWYgKHJvdXRlSW5mby50eXBlID09PSAncmVkaXJlY3QtaW50ZXJuYWwnKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgcm91dGVJbmZvLm5ld1VybCwgcm91dGVJbmZvLm5ld0FzLCBvcHRpb25zKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHsgdXJsOiByb3V0ZUluZm8uZGVzdGluYXRpb24sIHJvdXRlcjogdGhpcyB9KVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb21wb25lbnQ6IGFueSA9IHJvdXRlSW5mby5Db21wb25lbnRcbiAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LnVuc3RhYmxlX3NjcmlwdExvYWRlcikge1xuICAgICAgICBjb25zdCBzY3JpcHRzID0gW10uY29uY2F0KGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIoKSlcblxuICAgICAgICBzY3JpcHRzLmZvckVhY2goKHNjcmlwdDogYW55KSA9PiB7XG4gICAgICAgICAgaGFuZGxlQ2xpZW50U2NyaXB0TG9hZChzY3JpcHQucHJvcHMpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIGhhbmRsZSByZWRpcmVjdCBvbiBjbGllbnQtdHJhbnNpdGlvblxuICAgICAgaWYgKChyb3V0ZUluZm8uX19OX1NTRyB8fCByb3V0ZUluZm8uX19OX1NTUCkgJiYgcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzICYmXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gVXNlIHRoZSBkZXN0aW5hdGlvbiBmcm9tIHJlZGlyZWN0IHdpdGhvdXQgYWRkaW5nIGxvY2FsZVxuICAgICAgICAgIG9wdGlvbnMubG9jYWxlID0gZmFsc2VcblxuICAgICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIGRlc3RpbmF0aW9uIGlzIGludGVybmFsIChyZXNvbHZlcyB0byBhIHBhZ2UpIGFuZCBhdHRlbXB0XG4gICAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAgIC8vIGl0J3Mgbm90XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZGVzdGluYXRpb24uc3RhcnRzV2l0aCgnLycpICYmXG4gICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVF9CQVNFX1BBVEggIT09IGZhbHNlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRIcmVmID0gcGFyc2VSZWxhdGl2ZVVybChkZXN0aW5hdGlvbilcbiAgICAgICAgICAgIHBhcnNlZEhyZWYucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKFxuICAgICAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lLFxuICAgICAgICAgICAgICBwYWdlc1xuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsLCBhczogbmV3QXMgfSA9IHByZXBhcmVVcmxBcyhcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UobWV0aG9kLCBuZXdVcmwsIG5ld0FzLCBvcHRpb25zKVxuICAgICAgICAgIH1cbiAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7IHVybDogZGVzdGluYXRpb24sIHJvdXRlcjogdGhpcyB9KVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHRTdGF0ZS5pc1ByZXZpZXcgPSAhIXJvdXRlSW5mby5wcm9wcy5fX05fUFJFVklFV1xuXG4gICAgICAgIC8vIGhhbmRsZSBTU0cgZGF0YSA0MDRcbiAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5ub3RGb3VuZCA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgbGV0IG5vdEZvdW5kUm91dGVcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KCcvNDA0JylcbiAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSAnLzQwNCdcbiAgICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gJy9fZXJyb3InXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcm91dGVJbmZvID0gYXdhaXQgdGhpcy5nZXRSb3V0ZUluZm8oe1xuICAgICAgICAgICAgcm91dGU6IG5vdEZvdW5kUm91dGUsXG4gICAgICAgICAgICBwYXRobmFtZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgcm91dGVQcm9wczogeyBzaGFsbG93OiBmYWxzZSB9LFxuICAgICAgICAgICAgbG9jYWxlOiBuZXh0U3RhdGUubG9jYWxlLFxuICAgICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgICAgaXNOb3RGb3VuZDogdHJ1ZSxcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiAvNDA0YClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBpc1F1ZXJ5VXBkYXRpbmcgJiZcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9PT0gJy9fZXJyb3InICYmXG4gICAgICAgIHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcz8ucGFnZVByb3BzPy5zdGF0dXNDb2RlID09PSA1MDAgJiZcbiAgICAgICAgcm91dGVJbmZvLnByb3BzPy5wYWdlUHJvcHNcbiAgICAgICkge1xuICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDBcbiAgICAgIH1cblxuICAgICAgLy8gc2hhbGxvdyByb3V0aW5nIGlzIG9ubHkgYWxsb3dlZCBmb3Igc2FtZSBwYWdlIFVSTCBjaGFuZ2VzLlxuICAgICAgY29uc3QgaXNWYWxpZFNoYWxsb3dSb3V0ZSA9XG4gICAgICAgIG9wdGlvbnMuc2hhbGxvdyAmJiBuZXh0U3RhdGUucm91dGUgPT09IChyb3V0ZUluZm8ucm91dGUgPz8gcm91dGUpXG5cbiAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9XG4gICAgICAgIG9wdGlvbnMuc2Nyb2xsID8/ICghaXNRdWVyeVVwZGF0aW5nICYmICFpc1ZhbGlkU2hhbGxvd1JvdXRlKVxuICAgICAgY29uc3QgcmVzZXRTY3JvbGwgPSBzaG91bGRTY3JvbGwgPyB7IHg6IDAsIHk6IDAgfSA6IG51bGxcbiAgICAgIGNvbnN0IHVwY29taW5nU2Nyb2xsU3RhdGUgPSBmb3JjZWRTY3JvbGwgPz8gcmVzZXRTY3JvbGxcblxuICAgICAgLy8gdGhlIG5ldyBzdGF0ZSB0aGF0IHRoZSByb3V0ZXIgZ29ubmEgc2V0XG4gICAgICBjb25zdCB1cGNvbWluZ1JvdXRlclN0YXRlID0ge1xuICAgICAgICAuLi5uZXh0U3RhdGUsXG4gICAgICAgIHJvdXRlLFxuICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIGFzUGF0aDogY2xlYW5lZEFzLFxuICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZSxcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiB0aGUgcGFnZSBiZWluZyByZW5kZXJlZCBpcyB0aGUgNDA0IHBhZ2UsIHdlIHNob3VsZCBvbmx5IHVwZGF0ZSB0aGVcbiAgICAgIC8vIHF1ZXJ5IHBhcmFtZXRlcnMuIFJvdXRlIGNoYW5nZXMgaGVyZSBtaWdodCBhZGQgdGhlIGJhc2VQYXRoIHdoZW4gaXRcbiAgICAgIC8vIHdhc24ndCBvcmlnaW5hbGx5IHByZXNlbnQuIFRoaXMgaXMgYWxzbyB3aHkgdGhpcyBibG9jayBpcyBiZWZvcmUgdGhlXG4gICAgICAvLyBiZWxvdyBgY2hhbmdlU3RhdGVgIGNhbGwgd2hpY2ggdXBkYXRlcyB0aGUgYnJvd3NlcidzIGhpc3RvcnkgKGNoYW5naW5nXG4gICAgICAvLyB0aGUgVVJMKS5cbiAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgaXNFcnJvclJvdXRlKSB7XG4gICAgICAgIHJvdXRlSW5mbyA9IGF3YWl0IHRoaXMuZ2V0Um91dGVJbmZvKHtcbiAgICAgICAgICByb3V0ZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICBwYXRobmFtZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICBhcyxcbiAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgIHJvdXRlUHJvcHM6IHsgc2hhbGxvdzogZmFsc2UgfSxcbiAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgaXNQcmV2aWV3OiBuZXh0U3RhdGUuaXNQcmV2aWV3LFxuICAgICAgICAgIGlzUXVlcnlVcGRhdGluZzogaXNRdWVyeVVwZGF0aW5nICYmICF0aGlzLmlzRmFsbGJhY2ssXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCd0eXBlJyBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgbWlkZGxld2FyZSBlZmZlY3Qgb24gJHt0aGlzLnBhdGhuYW1lfWApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgdGhpcy5wYXRobmFtZSA9PT0gJy9fZXJyb3InICYmXG4gICAgICAgICAgc2VsZi5fX05FWFRfREFUQV9fLnByb3BzPy5wYWdlUHJvcHM/LnN0YXR1c0NvZGUgPT09IDUwMCAmJlxuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcz8ucGFnZVByb3BzXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGVuc3VyZSBzdGF0dXNDb2RlIGlzIHN0aWxsIGNvcnJlY3QgZm9yIHN0YXRpYyA1MDAgcGFnZVxuICAgICAgICAgIC8vIHdoZW4gdXBkYXRpbmcgcXVlcnkgaW5mb3JtYXRpb25cbiAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDBcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoaXNFcnJvcihlcnIpICYmIGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzLCByb3V0ZVByb3BzKVxuICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShtZXRob2QsIHVybCwgYXMsIG9wdGlvbnMpXG5cbiAgICAgIC8vIGZvciBxdWVyeSB1cGRhdGVzIHdlIGNhbiBza2lwIGl0IGlmIHRoZSBzdGF0ZSBpcyB1bmNoYW5nZWQgYW5kIHdlIGRvbid0XG4gICAgICAvLyBuZWVkIHRvIHNjcm9sbFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9uZXh0LmpzL2lzc3Vlcy8zNzEzOVxuICAgICAgY29uc3QgY2FuU2tpcFVwZGF0aW5nID1cbiAgICAgICAgaXNRdWVyeVVwZGF0aW5nICYmXG4gICAgICAgICF1cGNvbWluZ1Njcm9sbFN0YXRlICYmXG4gICAgICAgICFyZWFkeVN0YXRlQ2hhbmdlICYmXG4gICAgICAgICFsb2NhbGVDaGFuZ2UgJiZcbiAgICAgICAgY29tcGFyZVJvdXRlclN0YXRlcyh1cGNvbWluZ1JvdXRlclN0YXRlLCB0aGlzLnN0YXRlKVxuXG4gICAgICBpZiAoIWNhblNraXBVcGRhdGluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSlcbiAgICAgICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICAgICAgaWYgKGUuY2FuY2VsbGVkKSByb3V0ZUluZm8uZXJyb3IgPSByb3V0ZUluZm8uZXJyb3IgfHwgZVxuICAgICAgICAgIGVsc2UgdGhyb3cgZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdXRlSW5mby5lcnJvcikge1xuICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXG4gICAgICAgICAgICAgICdyb3V0ZUNoYW5nZUVycm9yJyxcbiAgICAgICAgICAgICAgcm91dGVJbmZvLmVycm9yLFxuICAgICAgICAgICAgICBjbGVhbmVkQXMsXG4gICAgICAgICAgICAgIHJvdXRlUHJvcHNcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyByb3V0ZUluZm8uZXJyb3JcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgaWYgKG5leHRTdGF0ZS5sb2NhbGUpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5sYW5nID0gbmV4dFN0YXRlLmxvY2FsZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdyb3V0ZUNoYW5nZUNvbXBsZXRlJywgYXMsIHJvdXRlUHJvcHMpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBIGhhc2ggbWFyayAjIGlzIHRoZSBvcHRpb25hbCBsYXN0IHBhcnQgb2YgYSBVUkxcbiAgICAgICAgY29uc3QgaGFzaFJlZ2V4ID0gLyMuKyQvXG4gICAgICAgIGlmIChzaG91bGRTY3JvbGwgJiYgaGFzaFJlZ2V4LnRlc3QoYXMpKSB7XG4gICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goYXMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChpc0Vycm9yKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGNoYW5nZVN0YXRlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhczogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFRyYW5zaXRpb25PcHRpb25zID0ge31cbiAgKTogdm9pZCB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5IGlzIG5vdCBhdmFpbGFibGUuYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnlbbWV0aG9kXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgV2FybmluZzogd2luZG93Lmhpc3RvcnkuJHttZXRob2R9IGlzIG5vdCBhdmFpbGFibGVgKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWV0aG9kICE9PSAncHVzaFN0YXRlJyB8fCBnZXRVUkwoKSAhPT0gYXMpIHtcbiAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3dcbiAgICAgIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0oXG4gICAgICAgIHtcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgYXMsXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAga2V5OiAodGhpcy5fa2V5ID0gbWV0aG9kICE9PSAncHVzaFN0YXRlJyA/IHRoaXMuX2tleSA6IGNyZWF0ZUtleSgpKSxcbiAgICAgICAgfSBhcyBIaXN0b3J5U3RhdGUsXG4gICAgICAgIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAnJyxcbiAgICAgICAgYXNcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihcbiAgICBlcnI6IEVycm9yICYgeyBjb2RlPzogYW55OyBjYW5jZWxsZWQ/OiBib29sZWFuIH0sXG4gICAgcGF0aG5hbWU6IHN0cmluZyxcbiAgICBxdWVyeTogUGFyc2VkVXJsUXVlcnksXG4gICAgYXM6IHN0cmluZyxcbiAgICByb3V0ZVByb3BzOiBSb3V0ZVByb3BlcnRpZXMsXG4gICAgbG9hZEVycm9yRmFpbD86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8+IHtcbiAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgIHRocm93IGVyclxuICAgIH1cblxuICAgIGlmIChpc0Fzc2V0RXJyb3IoZXJyKSB8fCBsb2FkRXJyb3JGYWlsKSB7XG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnIsIGFzLCByb3V0ZVByb3BzKVxuXG4gICAgICAvLyBJZiB3ZSBjYW4ndCBsb2FkIHRoZSBwYWdlIGl0IGNvdWxkIGJlIG9uZSBvZiBmb2xsb3dpbmcgcmVhc29uc1xuICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgIC8vICAyLiBQYWdlIGRvZXMgZXhpc3QgaW4gYSBkaWZmZXJlbnQgem9uZVxuICAgICAgLy8gIDMuIEludGVybmFsIGVycm9yIHdoaWxlIGxvYWRpbmcgdGhlIHBhZ2VcblxuICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgIHVybDogYXMsXG4gICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgIH0pXG5cbiAgICAgIC8vIENoYW5naW5nIHRoZSBVUkwgZG9lc24ndCBibG9jayBleGVjdXRpbmcgdGhlIGN1cnJlbnQgY29kZSBwYXRoLlxuICAgICAgLy8gU28gbGV0J3MgdGhyb3cgYSBjYW5jZWxsYXRpb24gZXJyb3Igc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgIHRocm93IGJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IoKVxuICAgIH1cblxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBwcm9wczogUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZFxuICAgICAgY29uc3QgeyBwYWdlOiBDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0gPVxuICAgICAgICBhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KCcvX2Vycm9yJylcblxuICAgICAgY29uc3Qgcm91dGVJbmZvOiBDb21wbGV0ZVByaXZhdGVSb3V0ZUluZm8gPSB7XG4gICAgICAgIHByb3BzLFxuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHN0eWxlU2hlZXRzLFxuICAgICAgICBlcnIsXG4gICAgICAgIGVycm9yOiBlcnIsXG4gICAgICB9XG5cbiAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgIH0gYXMgYW55KVxuICAgICAgICB9IGNhdGNoIChnaXBFcnIpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBlcnJvciBwYWdlIGBnZXRJbml0aWFsUHJvcHNgOiAnLCBnaXBFcnIpXG4gICAgICAgICAgcm91dGVJbmZvLnByb3BzID0ge31cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAocm91dGVJbmZvRXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihcbiAgICAgICAgaXNFcnJvcihyb3V0ZUluZm9FcnIpID8gcm91dGVJbmZvRXJyIDogbmV3IEVycm9yKHJvdXRlSW5mb0VyciArICcnKSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcyxcbiAgICAgICAgcm91dGVQcm9wcyxcbiAgICAgICAgdHJ1ZVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldFJvdXRlSW5mbyh7XG4gICAgcm91dGU6IHJlcXVlc3RlZFJvdXRlLFxuICAgIHBhdGhuYW1lLFxuICAgIHF1ZXJ5LFxuICAgIGFzLFxuICAgIHJlc29sdmVkQXMsXG4gICAgcm91dGVQcm9wcyxcbiAgICBsb2NhbGUsXG4gICAgaGFzTWlkZGxld2FyZSxcbiAgICBpc1ByZXZpZXcsXG4gICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgIGlzUXVlcnlVcGRhdGluZyxcbiAgICBpc01pZGRsZXdhcmVSZXdyaXRlLFxuICAgIGlzTm90Rm91bmQsXG4gIH06IHtcbiAgICByb3V0ZTogc3RyaW5nXG4gICAgcGF0aG5hbWU6IHN0cmluZ1xuICAgIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICAgIGFzOiBzdHJpbmdcbiAgICByZXNvbHZlZEFzOiBzdHJpbmdcbiAgICBoYXNNaWRkbGV3YXJlPzogYm9vbGVhblxuICAgIHJvdXRlUHJvcHM6IFJvdXRlUHJvcGVydGllc1xuICAgIGxvY2FsZTogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgaXNQcmV2aWV3OiBib29sZWFuXG4gICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlPzogYm9vbGVhblxuICAgIGlzUXVlcnlVcGRhdGluZz86IGJvb2xlYW5cbiAgICBpc01pZGRsZXdhcmVSZXdyaXRlPzogYm9vbGVhblxuICAgIGlzTm90Rm91bmQ/OiBib29sZWFuXG4gIH0pIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIGByb3V0ZWAgYmluZGluZyBjYW4gY2hhbmdlIGlmIHRoZXJlJ3MgYSByZXdyaXRlXG4gICAgICogc28gd2Uga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgcmVxdWVzdGVkIHJvdXRlXG4gICAgICogc28gd2UgY2FuIHN0b3JlIHRoZSBjYWNoZSBmb3IgaXQgYW5kIGF2b2lkIHJlLXJlcXVlc3RpbmcgZXZlcnkgdGltZVxuICAgICAqIGZvciBzaGFsbG93IHJvdXRpbmcgcHVycG9zZXMuXG4gICAgICovXG4gICAgbGV0IHJvdXRlID0gcmVxdWVzdGVkUm91dGVcblxuICAgIHRyeSB7XG4gICAgICBsZXQgZXhpc3RpbmdJbmZvOiBQcml2YXRlUm91dGVJbmZvIHwgdW5kZWZpbmVkID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXVxuICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUpIHtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5mb1xuICAgICAgfVxuXG4gICAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHsgcm91dGUsIHJvdXRlcjogdGhpcyB9KVxuXG4gICAgICBpZiAoaGFzTWlkZGxld2FyZSkge1xuICAgICAgICBleGlzdGluZ0luZm8gPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9XG4gICAgICAgIGV4aXN0aW5nSW5mbyAmJlxuICAgICAgICAhKCdpbml0aWFsJyBpbiBleGlzdGluZ0luZm8pICYmXG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnXG4gICAgICAgICAgPyBleGlzdGluZ0luZm9cbiAgICAgICAgICA6IHVuZGVmaW5lZFxuXG4gICAgICBjb25zdCBpc0JhY2tncm91bmQgPSBpc1F1ZXJ5VXBkYXRpbmdcbiAgICAgIGNvbnN0IGZldGNoTmV4dERhdGFQYXJhbXM6IEZldGNoTmV4dERhdGFQYXJhbXMgPSB7XG4gICAgICAgIGRhdGFIcmVmOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgIGhyZWY6IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHsgcGF0aG5hbWUsIHF1ZXJ5IH0pLFxuICAgICAgICAgIHNraXBJbnRlcnBvbGF0aW9uOiB0cnVlLFxuICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/ICcvNDA0JyA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgbG9jYWxlLFxuICAgICAgICB9KSxcbiAgICAgICAgaGFzTWlkZGxld2FyZTogdHJ1ZSxcbiAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IHRoaXMuaXNTc3IsXG4gICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgaW5mbGlnaHRDYWNoZTogaXNCYWNrZ3JvdW5kID8gdGhpcy5zYmMgOiB0aGlzLnNkYyxcbiAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICBpc0JhY2tncm91bmQsXG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhOlxuICAgICAgICB8IFdpdGhNaWRkbGV3YXJlRWZmZWN0c091dHB1dFxuICAgICAgICB8IChQaWNrPFdpdGhNaWRkbGV3YXJlRWZmZWN0c091dHB1dCwgJ2pzb24nPiAmXG4gICAgICAgICAgICBPbWl0PFBhcnRpYWw8V2l0aE1pZGRsZXdhcmVFZmZlY3RzT3V0cHV0PiwgJ2pzb24nPilcbiAgICAgICAgfCBudWxsID1cbiAgICAgICAgaXNRdWVyeVVwZGF0aW5nICYmICFpc01pZGRsZXdhcmVSZXdyaXRlXG4gICAgICAgICAgPyBudWxsXG4gICAgICAgICAgOiBhd2FpdCB3aXRoTWlkZGxld2FyZUVmZmVjdHMoe1xuICAgICAgICAgICAgICBmZXRjaERhdGE6ICgpID0+IGZldGNoTmV4dERhdGEoZmV0Y2hOZXh0RGF0YVBhcmFtcyksXG4gICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/ICcvNDA0JyA6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICByb3V0ZXI6IHRoaXMsXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhcmQgZXJyb3IgZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nXG4gICAgICAgICAgICAgIC8vIGFzIGl0J3MgdW4tbmVjZXNzYXJ5IGFuZCBkb2Vzbid0IG5lZWQgdG8gYmUgZmF0YWxcbiAgICAgICAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgZmFsbGJhY2sgcm91dGUgYW5kIHRoZSBwcm9wcyBjYW4ndFxuICAgICAgICAgICAgICAvLyBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgICB9KVxuXG4gICAgICAvLyB3aGVuIHJlbmRlcmluZyBlcnJvciByb3V0ZXMgd2UgZG9uJ3QgYXBwbHkgbWlkZGxld2FyZVxuICAgICAgLy8gZWZmZWN0c1xuICAgICAgaWYgKGRhdGEgJiYgKHBhdGhuYW1lID09PSAnL19lcnJvcicgfHwgcGF0aG5hbWUgPT09ICcvNDA0JykpIHtcbiAgICAgICAgZGF0YS5lZmZlY3QgPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0geyBqc29uOiBzZWxmLl9fTkVYVF9EQVRBX18ucHJvcHMgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEuanNvbiA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wc1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZUNhbmNlbGxlZCgpXG5cbiAgICAgIGlmIChcbiAgICAgICAgZGF0YT8uZWZmZWN0Py50eXBlID09PSAncmVkaXJlY3QtaW50ZXJuYWwnIHx8XG4gICAgICAgIGRhdGE/LmVmZmVjdD8udHlwZSA9PT0gJ3JlZGlyZWN0LWV4dGVybmFsJ1xuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmVmZmVjdFxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YT8uZWZmZWN0Py50eXBlID09PSAncmV3cml0ZScpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRSb3V0ZSA9IHJlbW92ZVRyYWlsaW5nU2xhc2goZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmKVxuICAgICAgICBjb25zdCBwYWdlcyA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpXG5cbiAgICAgICAgLy8gZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nIHRoZSBwYWdlIG11c3QgbWF0Y2ggYWx0aG91Z2ggZHVyaW5nXG4gICAgICAgIC8vIGNsaWVudC10cmFuc2l0aW9uIGEgcmVkaXJlY3QgdGhhdCBkb2Vzbid0IG1hdGNoIGEgcGFnZVxuICAgICAgICAvLyBjYW4gYmUgcmV0dXJuZWQgYW5kIHRoaXMgc2hvdWxkIHRyaWdnZXIgYSBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgLy8gd2hpY2ggaXMgdmFsaWQgZm9yIGluY3JlbWVudGFsIG1pZ3JhdGlvblxuICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZyB8fCBwYWdlcy5pbmNsdWRlcyhyZXNvbHZlZFJvdXRlKSkge1xuICAgICAgICAgIHJvdXRlID0gcmVzb2x2ZWRSb3V0ZVxuICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmXG4gICAgICAgICAgcXVlcnkgPSB7IC4uLnF1ZXJ5LCAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeSB9XG4gICAgICAgICAgcmVzb2x2ZWRBcyA9IHJlbW92ZUJhc2VQYXRoKFxuICAgICAgICAgICAgbm9ybWFsaXplTG9jYWxlUGF0aChkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKVxuICAgICAgICAgICAgICAucGF0aG5hbWVcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvLyBDaGVjayBhZ2FpbiB0aGUgY2FjaGUgd2l0aCB0aGUgbmV3IGRlc3RpbmF0aW9uLlxuICAgICAgICAgIGV4aXN0aW5nSW5mbyA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICByb3V0ZVByb3BzLnNoYWxsb3cgJiZcbiAgICAgICAgICAgIGV4aXN0aW5nSW5mbyAmJlxuICAgICAgICAgICAgdGhpcy5yb3V0ZSA9PT0gcm91dGUgJiZcbiAgICAgICAgICAgICFoYXNNaWRkbGV3YXJlXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWF0Y2ggd2l0aCB0aGUgY3VycmVudCByb3V0ZSBkdWUgdG8gcmV3cml0ZSxcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjb3B5IHRoZSBleGlzdGluZyBpbmZvcm1hdGlvbiB0byB0aGUgcmV3cml0dGVuIG9uZS5cbiAgICAgICAgICAgIC8vIFRoZW4sIHdlIHJldHVybiB0aGUgaW5mb3JtYXRpb24gYWxvbmcgd2l0aCB0aGUgbWF0Y2hlZCByb3V0ZS5cbiAgICAgICAgICAgIHJldHVybiB7IC4uLmV4aXN0aW5nSW5mbywgcm91dGUgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBUElSb3V0ZShyb3V0ZSkpIHtcbiAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oeyB1cmw6IGFzLCByb3V0ZXI6IHRoaXMgfSlcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPG5ldmVyPigoKSA9PiB7fSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGVJbmZvID1cbiAgICAgICAgY2FjaGVkUm91dGVJbmZvIHx8XG4gICAgICAgIChhd2FpdCB0aGlzLmZldGNoQ29tcG9uZW50KHJvdXRlKS50aGVuPENvbXBsZXRlUHJpdmF0ZVJvdXRlSW5mbz4oXG4gICAgICAgICAgKHJlcykgPT4gKHtcbiAgICAgICAgICAgIENvbXBvbmVudDogcmVzLnBhZ2UsXG4gICAgICAgICAgICBzdHlsZVNoZWV0czogcmVzLnN0eWxlU2hlZXRzLFxuICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQLFxuICAgICAgICAgIH0pXG4gICAgICAgICkpXG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPVxuICAgICAgICAgIHJlcXVpcmUoJ25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pcycpIGFzIHR5cGVvZiBpbXBvcnQoJ25leHQvZGlzdC9jb21waWxlZC9yZWFjdC1pcycpXG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHJvdXRlSW5mby5Db21wb25lbnQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke3BhdGhuYW1lfVwiYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgd2FzQmFpbGVkUHJlZmV0Y2ggPSBkYXRhPy5yZXNwb25zZT8uaGVhZGVycy5nZXQoJ3gtbWlkZGxld2FyZS1za2lwJylcblxuICAgICAgY29uc3Qgc2hvdWxkRmV0Y2hEYXRhID0gcm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1BcblxuICAgICAgLy8gRm9yIG5vbi1TU0cgcHJlZmV0Y2hlcyB0aGF0IGJhaWxlZCBiZWZvcmUgc2VuZGluZyBkYXRhXG4gICAgICAvLyB3ZSBjbGVhciB0aGUgY2FjaGUgdG8gZmV0Y2ggZnVsbCByZXNwb25zZVxuICAgICAgaWYgKHdhc0JhaWxlZFByZWZldGNoICYmIGRhdGE/LmRhdGFIcmVmKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tkYXRhLmRhdGFIcmVmXVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IHByb3BzLCBjYWNoZUtleSB9ID0gYXdhaXQgdGhpcy5fZ2V0RGF0YShhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRGZXRjaERhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YT8uanNvbiAmJiAhd2FzQmFpbGVkUHJlZmV0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LCBwcm9wczogZGF0YS5qc29uIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBkYXRhSHJlZiA9IGRhdGE/LmRhdGFIcmVmXG4gICAgICAgICAgICA/IGRhdGEuZGF0YUhyZWZcbiAgICAgICAgICAgIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICBocmVmOiBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lLCBxdWVyeSB9KSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgY29uc3QgZmV0Y2hlZCA9IGF3YWl0IGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdGhpcy5pc1NzcixcbiAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHdhc0JhaWxlZFByZWZldGNoID8ge30gOiB0aGlzLnNkYyxcbiAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgIGlzUHJlZmV0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlLFxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FjaGVLZXk6IGZldGNoZWQuY2FjaGVLZXksXG4gICAgICAgICAgICBwcm9wczogZmV0Y2hlZC5qc29uIHx8IHt9LFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgcHJvcHM6IGF3YWl0IHRoaXMuZ2V0SW5pdGlhbFByb3BzKFxuICAgICAgICAgICAgcm91dGVJbmZvLkNvbXBvbmVudCxcbiAgICAgICAgICAgIC8vIHdlIHByb3ZpZGUgQXBwVHJlZSBsYXRlciBzbyB0aGlzIG5lZWRzIHRvIGJlIGBhbnlgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICBsb2NhbGVzOiB0aGlzLmxvY2FsZXMsXG4gICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZSxcbiAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgKSxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgLy8gT25seSBidXN0IHRoZSBkYXRhIGNhY2hlIGZvciBTU1Agcm91dGVzIGFsdGhvdWdoXG4gICAgICAvLyBtaWRkbGV3YXJlIGNhbiBza2lwIGNhY2hlIHBlciByZXF1ZXN0IHdpdGhcbiAgICAgIC8vIHgtbWlkZGxld2FyZS1jYWNoZTogbm8tY2FjaGUgYXMgd2VsbFxuICAgICAgaWYgKHJvdXRlSW5mby5fX05fU1NQICYmIGZldGNoTmV4dERhdGFQYXJhbXMuZGF0YUhyZWYgJiYgY2FjaGVLZXkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2NhY2hlS2V5XVxuICAgICAgfVxuXG4gICAgICAvLyB3ZSBraWNrIG9mZiBhIEhFQUQgcmVxdWVzdCBpbiB0aGUgYmFja2dyb3VuZFxuICAgICAgLy8gd2hlbiBhIG5vbi1wcmVmZXRjaCByZXF1ZXN0IGlzIG1hZGUgdG8gc2lnbmFsIHJldmFsaWRhdGlvblxuICAgICAgaWYgKFxuICAgICAgICAhdGhpcy5pc1ByZXZpZXcgJiZcbiAgICAgICAgcm91dGVJbmZvLl9fTl9TU0cgJiZcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgICAgIWlzUXVlcnlVcGRhdGluZ1xuICAgICAgKSB7XG4gICAgICAgIGZldGNoTmV4dERhdGEoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgZmV0Y2hOZXh0RGF0YVBhcmFtcywge1xuICAgICAgICAgICAgaXNCYWNrZ3JvdW5kOiB0cnVlLFxuICAgICAgICAgICAgcGVyc2lzdENhY2hlOiBmYWxzZSxcbiAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2JjLFxuICAgICAgICAgIH0pXG4gICAgICAgICkuY2F0Y2goKCkgPT4ge30pXG4gICAgICB9XG5cbiAgICAgIHByb3BzLnBhZ2VQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLnBhZ2VQcm9wcylcbiAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICByb3V0ZUluZm8ucm91dGUgPSByb3V0ZVxuICAgICAgcm91dGVJbmZvLnF1ZXJ5ID0gcXVlcnlcbiAgICAgIHJvdXRlSW5mby5yZXNvbHZlZEFzID0gcmVzb2x2ZWRBc1xuICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mb1xuXG4gICAgICByZXR1cm4gcm91dGVJbmZvXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYW5kbGVSb3V0ZUluZm9FcnJvcihcbiAgICAgICAgZ2V0UHJvcGVyRXJyb3IoZXJyKSxcbiAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBhcyxcbiAgICAgICAgcm91dGVQcm9wc1xuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2V0KFxuICAgIHN0YXRlOiB0eXBlb2YgdGhpcy5zdGF0ZSxcbiAgICBkYXRhOiBQcml2YXRlUm91dGVJbmZvLFxuICAgIHJlc2V0U2Nyb2xsOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZVxuXG4gICAgcmV0dXJuIHRoaXMuc3ViKFxuICAgICAgZGF0YSxcbiAgICAgIHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnQgYXMgQXBwQ29tcG9uZW50LFxuICAgICAgcmVzZXRTY3JvbGxcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovXG4gIGJlZm9yZVBvcFN0YXRlKGNiOiBCZWZvcmVQb3BTdGF0ZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYnBzID0gY2JcbiAgfVxuXG4gIG9ubHlBSGFzaENoYW5nZShhczogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgW29sZFVybE5vSGFzaCwgb2xkSGFzaF0gPSB0aGlzLmFzUGF0aC5zcGxpdCgnIycsIDIpXG4gICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdCgnIycsIDIpXG5cbiAgICAvLyBNYWtlcyBzdXJlIHdlIHNjcm9sbCB0byB0aGUgcHJvdmlkZWQgaGFzaCBpZiB0aGUgdXJsL2hhc2ggYXJlIHRoZSBzYW1lXG4gICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdXJscyBhcmUgY2hhbmdlLCB0aGVyZSdzIG1vcmUgdGhhbiBhIGhhc2ggY2hhbmdlXG4gICAgaWYgKG9sZFVybE5vSGFzaCAhPT0gbmV3VXJsTm9IYXNoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAvLyBUaGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBoYW5kbGUgYm90aCB0aGUgZW50ZXIgYW5kXG4gICAgLy8gbGVhdmUgaGFzaCA9PT0gJycgY2FzZXMuIFRoZSBpZGVudGl0eSBjYXNlIGZhbGxzIHRocm91Z2hcbiAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgIHJldHVybiBvbGRIYXNoICE9PSBuZXdIYXNoXG4gIH1cblxuICBzY3JvbGxUb0hhc2goYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGNvbnN0IFssIGhhc2ggPSAnJ10gPSBhcy5zcGxpdCgnIycsIDIpXG5cbiAgICBkaXNhYmxlU21vb3RoU2Nyb2xsRHVyaW5nUm91dGVUcmFuc2l0aW9uKFxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBTY3JvbGwgdG8gdG9wIGlmIHRoZSBoYXNoIGlzIGp1c3QgYCNgIHdpdGggbm8gdmFsdWUgb3IgYCN0b3BgXG4gICAgICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgICAgICBpZiAoaGFzaCA9PT0gJycgfHwgaGFzaCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY29kZSBoYXNoIHRvIG1ha2Ugbm9uLWxhdGluIGFuY2hvciB3b3Jrcy5cbiAgICAgICAgY29uc3QgcmF3SGFzaCA9IGRlY29kZVVSSUNvbXBvbmVudChoYXNoKVxuICAgICAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgICAgICBjb25zdCBpZEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocmF3SGFzaClcbiAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICBpZEVsLnNjcm9sbEludG9WaWV3KClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGVsZW1lbnQgd2l0aCB0aGUgaWQsIHdlIGNoZWNrIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKHJhd0hhc2gpWzBdXG4gICAgICAgIGlmIChuYW1lRWwpIHtcbiAgICAgICAgICBuYW1lRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBvbmx5SGFzaENoYW5nZTogdGhpcy5vbmx5QUhhc2hDaGFuZ2UoYXMpLFxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIHVybElzTmV3KGFzUGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGhcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovXG4gIGFzeW5jIHByZWZldGNoKFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzUGF0aDogc3RyaW5nID0gdXJsLFxuICAgIG9wdGlvbnM6IFByZWZldGNoT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIGlzQm90KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgLy8gTm8gcHJlZmV0Y2hlcyBmb3IgYm90cyB0aGF0IHJlbmRlciB0aGUgbGluayBzaW5jZSB0aGV5IGFyZSB0eXBpY2FsbHkgbmF2aWdhdGluZ1xuICAgICAgLy8gbGlua3MgdmlhIHRoZSBlcXVpdmFsZW50IG9mIGEgaGFyZCBuYXZpZ2F0aW9uIGFuZCBoZW5jZSBuZXZlciB1dGlsaXplIHRoZXNlXG4gICAgICAvLyBwcmVmZXRjaGVzLlxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGxldCBwYXJzZWQgPSBwYXJzZVJlbGF0aXZlVXJsKHVybClcbiAgICBjb25zdCB1cmxQYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZVxuXG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWRcbiAgICBjb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gcGF0aG5hbWVcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHBhdGhuYW1lID0gbm9ybWFsaXplTG9jYWxlUGF0aCEocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWVcbiAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWVcbiAgICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuXG4gICAgICAgIGxldCBwYXJzZWRBcyA9IHBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKVxuICAgICAgICBjb25zdCBsb2NhbGVQYXRoUmVzdWx0ID0gbm9ybWFsaXplTG9jYWxlUGF0aCEoXG4gICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUsXG4gICAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICAgIClcbiAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSBsb2NhbGVQYXRoUmVzdWx0LnBhdGhuYW1lXG4gICAgICAgIG9wdGlvbnMubG9jYWxlID0gbG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSB8fCB0aGlzLmRlZmF1bHRMb2NhbGVcbiAgICAgICAgYXNQYXRoID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkQXMpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgcGFnZXMgPSBhd2FpdCB0aGlzLnBhZ2VMb2FkZXIuZ2V0UGFnZUxpc3QoKVxuICAgIGxldCByZXNvbHZlZEFzID0gYXNQYXRoXG5cbiAgICBjb25zdCBsb2NhbGUgPVxuICAgICAgdHlwZW9mIG9wdGlvbnMubG9jYWxlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IG9wdGlvbnMubG9jYWxlIHx8IHVuZGVmaW5lZFxuICAgICAgICA6IHRoaXMubG9jYWxlXG5cbiAgICBjb25zdCBpc01pZGRsZXdhcmVNYXRjaCA9IGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgIGFzUGF0aDogYXNQYXRoLFxuICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICByb3V0ZXI6IHRoaXMsXG4gICAgfSlcblxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTICYmIGFzUGF0aC5zdGFydHNXaXRoKCcvJykpIHtcbiAgICAgIGxldCByZXdyaXRlczogYW55XG4gICAgICA7KHsgX19yZXdyaXRlczogcmV3cml0ZXMgfSA9IGF3YWl0IGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKSlcblxuICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSByZXNvbHZlUmV3cml0ZXMoXG4gICAgICAgIGFkZEJhc2VQYXRoKGFkZExvY2FsZShhc1BhdGgsIHRoaXMubG9jYWxlKSwgdHJ1ZSksXG4gICAgICAgIHBhZ2VzLFxuICAgICAgICByZXdyaXRlcyxcbiAgICAgICAgcGFyc2VkLnF1ZXJ5LFxuICAgICAgICAocDogc3RyaW5nKSA9PiByZXNvbHZlRHluYW1pY1JvdXRlKHAsIHBhZ2VzKSxcbiAgICAgICAgdGhpcy5sb2NhbGVzXG4gICAgICApXG5cbiAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5leHRlcm5hbERlc3QpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgcmVzb2x2ZWRBcyA9IHJlbW92ZUxvY2FsZShcbiAgICAgICAgICByZW1vdmVCYXNlUGF0aChyZXdyaXRlc1Jlc3VsdC5hc1BhdGgpLFxuICAgICAgICAgIHRoaXMubG9jYWxlXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHJld3JpdGVzUmVzdWx0Lm1hdGNoZWRQYWdlICYmIHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZikge1xuICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgIC8vIGFsbG93IHRoZSBjb3JyZWN0IHBhZ2UgY2h1bmsgdG8gYmUgbG9hZGVkXG4gICAgICAgIHBhdGhuYW1lID0gcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmXG4gICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG5cbiAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpXG5cbiAgICBpZiAoaXNEeW5hbWljUm91dGUocGFyc2VkLnBhdGhuYW1lKSkge1xuICAgICAgcGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWVcbiAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICBxdWVyeSxcbiAgICAgICAgZ2V0Um91dGVNYXRjaGVyKGdldFJvdXRlUmVnZXgocGFyc2VkLnBhdGhuYW1lKSkoXG4gICAgICAgICAgcGFyc2VQYXRoKGFzUGF0aCkucGF0aG5hbWVcbiAgICAgICAgKSB8fCB7fVxuICAgICAgKVxuXG4gICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgIHVybCA9IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHBhcnNlZClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID1cbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9NSURETEVXQVJFX1BSRUZFVENIID09PSAnc3RyaWN0J1xuICAgICAgICA/IG51bGxcbiAgICAgICAgOiBhd2FpdCB3aXRoTWlkZGxld2FyZUVmZmVjdHMoe1xuICAgICAgICAgICAgZmV0Y2hEYXRhOiAoKSA9PlxuICAgICAgICAgICAgICBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICBkYXRhSHJlZjogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgIGhyZWY6IGZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IG9yaWdpbmFsUGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogdGhpcy5zZGMsXG4gICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhdGhpcy5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgIH0pXG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSB3YXMgYSByZXdyaXRlIHdlIGFwcGx5IHRoZSBlZmZlY3RzIG9mIHRoZSByZXdyaXRlIG9uIHRoZVxuICAgICAqIGN1cnJlbnQgcGFyYW1ldGVycyBmb3IgdGhlIHByZWZldGNoLlxuICAgICAqL1xuICAgIGlmIChkYXRhPy5lZmZlY3QudHlwZSA9PT0gJ3Jld3JpdGUnKSB7XG4gICAgICBwYXJzZWQucGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWZcbiAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmXG4gICAgICBxdWVyeSA9IHsgLi4ucXVlcnksIC4uLmRhdGEuZWZmZWN0LnBhcnNlZEFzLnF1ZXJ5IH1cbiAgICAgIHJlc29sdmVkQXMgPSBkYXRhLmVmZmVjdC5wYXJzZWRBcy5wYXRobmFtZVxuICAgICAgdXJsID0gZm9ybWF0V2l0aFZhbGlkYXRpb24ocGFyc2VkKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIHRoZXJlIGlzIGEgcmVkaXJlY3QgdG8gYW4gZXh0ZXJuYWwgZGVzdGluYXRpb24gdGhlbiB3ZSBkb24ndCBoYXZlXG4gICAgICogdG8gcHJlZmV0Y2ggY29udGVudCBhcyBpdCB3aWxsIGJlIHVudXNlZC5cbiAgICAgKi9cbiAgICBpZiAoZGF0YT8uZWZmZWN0LnR5cGUgPT09ICdyZWRpcmVjdC1leHRlcm5hbCcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRobmFtZSlcblxuICAgIGlmIChhd2FpdCB0aGlzLl9iZmwoYXNQYXRoLCByZXNvbHZlZEFzLCBvcHRpb25zLmxvY2FsZSwgdHJ1ZSkpIHtcbiAgICAgIHRoaXMuY29tcG9uZW50c1t1cmxQYXRobmFtZV0gPSB7IF9fYXBwUm91dGVyOiB0cnVlIH0gYXMgYW55XG4gICAgfVxuXG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5wYWdlTG9hZGVyLl9pc1NzZyhyb3V0ZSkudGhlbigoaXNTc2cpID0+IHtcbiAgICAgICAgcmV0dXJuIGlzU3NnXG4gICAgICAgICAgPyBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgZGF0YUhyZWY6IGRhdGE/Lmpzb25cbiAgICAgICAgICAgICAgICA/IGRhdGE/LmRhdGFIcmVmXG4gICAgICAgICAgICAgICAgOiB0aGlzLnBhZ2VMb2FkZXIuZ2V0RGF0YUhyZWYoe1xuICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOlxuICAgICAgICAgICAgICAgIG9wdGlvbnMudW5zdGFibGVfc2tpcENsaWVudENhY2hlIHx8XG4gICAgICAgICAgICAgICAgKG9wdGlvbnMucHJpb3JpdHkgJiZcbiAgICAgICAgICAgICAgICAgICEhcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIC50aGVuKCgpID0+IGZhbHNlKVxuICAgICAgICAgICAgICAuY2F0Y2goKCkgPT4gZmFsc2UpXG4gICAgICAgICAgOiBmYWxzZVxuICAgICAgfSksXG4gICAgICB0aGlzLnBhZ2VMb2FkZXJbb3B0aW9ucy5wcmlvcml0eSA/ICdsb2FkUGFnZScgOiAncHJlZmV0Y2gnXShyb3V0ZSksXG4gICAgXSlcbiAgfVxuXG4gIGFzeW5jIGZldGNoQ29tcG9uZW50KHJvdXRlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSBnZXRDYW5jZWxsZWRIYW5kbGVyKHsgcm91dGUsIHJvdXRlcjogdGhpcyB9KVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSlcbiAgICAgIGhhbmRsZUNhbmNlbGxlZCgpXG5cbiAgICAgIHJldHVybiBjb21wb25lbnRSZXN1bHRcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGhhbmRsZUNhbmNlbGxlZCgpXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cblxuICBfZ2V0RGF0YTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9XG4gICAgdGhpcy5jbGMgPSBjYW5jZWxcbiAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICBjb25zdCBlcnI6IGFueSA9IG5ldyBFcnJvcignTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZCcpXG4gICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBnZXRJbml0aWFsUHJvcHMoXG4gICAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlLFxuICAgIGN0eDogTmV4dFBhZ2VDb250ZXh0XG4gICk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgYW55Pj4ge1xuICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgfSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXVxuICAgIGNvbnN0IEFwcFRyZWUgPSB0aGlzLl93cmFwQXBwKEFwcCBhcyBBcHBDb21wb25lbnQpXG4gICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlXG4gICAgcmV0dXJuIGxvYWRHZXRJbml0aWFsUHJvcHM8QXBwQ29udGV4dFR5cGU8Um91dGVyPj4oQXBwLCB7XG4gICAgICBBcHBUcmVlLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgY3R4LFxuICAgIH0pXG4gIH1cblxuICBnZXQgcm91dGUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb3V0ZVxuICB9XG5cbiAgZ2V0IHBhdGhuYW1lKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGF0aG5hbWVcbiAgfVxuXG4gIGdldCBxdWVyeSgpOiBQYXJzZWRVcmxRdWVyeSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucXVlcnlcbiAgfVxuXG4gIGdldCBhc1BhdGgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5hc1BhdGhcbiAgfVxuXG4gIGdldCBsb2NhbGUoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5sb2NhbGVcbiAgfVxuXG4gIGdldCBpc0ZhbGxiYWNrKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmlzRmFsbGJhY2tcbiAgfVxuXG4gIGdldCBpc1ByZXZpZXcoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNQcmV2aWV3XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVLZXkiLCJSb3V0ZXIiLCJtYXRjaGVzTWlkZGxld2FyZSIsInJlc29sdmVSZXdyaXRlcyIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfSEFTX1JFV1JJVEVTIiwicmVxdWlyZSIsImRlZmF1bHQiLCJidWlsZENhbmNlbGxhdGlvbkVycm9yIiwiT2JqZWN0IiwiYXNzaWduIiwiRXJyb3IiLCJjYW5jZWxsZWQiLCJvcHRpb25zIiwibWF0Y2hlcnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJvdXRlciIsInBhZ2VMb2FkZXIiLCJnZXRNaWRkbGV3YXJlIiwicGF0aG5hbWUiLCJhc1BhdGhuYW1lIiwicGFyc2VQYXRoIiwiYXNQYXRoIiwiY2xlYW5lZEFzIiwiaGFzQmFzZVBhdGgiLCJyZW1vdmVCYXNlUGF0aCIsImFzV2l0aEJhc2VQYXRoQW5kTG9jYWxlIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJsb2NhbGUiLCJzb21lIiwibSIsIlJlZ0V4cCIsInJlZ2V4cCIsInRlc3QiLCJzdHJpcE9yaWdpbiIsInVybCIsIm9yaWdpbiIsImdldExvY2F0aW9uT3JpZ2luIiwic3RhcnRzV2l0aCIsInN1YnN0cmluZyIsImxlbmd0aCIsInByZXBhcmVVcmxBcyIsImFzIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsInJlc29sdmVIcmVmIiwiaHJlZldhc0Fic29sdXRlIiwiYXNXYXNBYnNvbHV0ZSIsInByZXBhcmVkVXJsIiwicHJlcGFyZWRBcyIsInJlc29sdmVEeW5hbWljUm91dGUiLCJwYWdlcyIsImNsZWFuUGF0aG5hbWUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZGVub3JtYWxpemVQYWdlUGF0aCIsImluY2x1ZGVzIiwicGFnZSIsImlzRHluYW1pY1JvdXRlIiwiZ2V0Um91dGVSZWdleCIsInJlIiwiZ2V0TWlkZGxld2FyZURhdGEiLCJzb3VyY2UiLCJyZXNwb25zZSIsIm5leHRDb25maWciLCJiYXNlUGF0aCIsImkxOG4iLCJsb2NhbGVzIiwidHJhaWxpbmdTbGFzaCIsIkJvb2xlYW4iLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJyZXdyaXRlSGVhZGVyIiwiaGVhZGVycyIsImdldCIsInJld3JpdGVUYXJnZXQiLCJtYXRjaGVkUGF0aCIsIk1BVENIRURfUEFUSF9IRUFERVIiLCJfX05FWFRfRVhURVJOQUxfTUlERExFV0FSRV9SRVdSSVRFX1JFU09MVkUiLCJwYXJzZWRSZXdyaXRlVGFyZ2V0IiwicGFyc2VSZWxhdGl2ZVVybCIsInBhdGhuYW1lSW5mbyIsImdldE5leHRQYXRobmFtZUluZm8iLCJwYXJzZURhdGEiLCJmc1BhdGhuYW1lIiwiYWxsIiwiZ2V0UGFnZUxpc3QiLCJnZXRDbGllbnRCdWlsZE1hbmlmZXN0IiwidGhlbiIsIl9fcmV3cml0ZXMiLCJyZXdyaXRlcyIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJwYXJzZWRTb3VyY2UiLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJxdWVyeSIsInBhdGgiLCJtYXRjaGVkUGFnZSIsInBhcnNlZEFzIiwicmVzb2x2ZWRQYXRobmFtZSIsIm1hdGNoZXMiLCJnZXRSb3V0ZU1hdGNoZXIiLCJ0eXBlIiwic3JjIiwiZm9ybWF0TmV4dFBhdGhuYW1lSW5mbyIsImRlZmF1bHRMb2NhbGUiLCJidWlsZElkIiwiZGVzdGluYXRpb24iLCJoYXNoIiwicmVkaXJlY3RUYXJnZXQiLCJuZXdBcyIsIm5ld1VybCIsIndpdGhNaWRkbGV3YXJlRWZmZWN0cyIsImZldGNoRGF0YSIsImRhdGEiLCJlZmZlY3QiLCJkYXRhSHJlZiIsImpzb24iLCJ0ZXh0IiwiY2FjaGVLZXkiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsIm1ldGhvZCIsIm9rIiwic3RhdHVzIiwidHJ5VG9QYXJzZUFzSlNPTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwiaHJlZiIsIlVSTCIsImxvY2F0aW9uIiwiZGVwbG95bWVudElkIiwiZ2V0RGVwbG95bWVudElkIiwiZ2V0RGF0YSIsInBhcmFtcyIsInB1cnBvc2UiLCJub3RGb3VuZCIsIm1hcmtBc3NldEVycm9yIiwiTk9ERV9FTlYiLCJjYXRjaCIsImVyciIsIm1lc3NhZ2UiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJzbGljZSIsImhhbmRsZUhhcmROYXZpZ2F0aW9uIiwiZ2V0Q2FuY2VsbGVkSGFuZGxlciIsInJvdXRlIiwiY2FuY2VsIiwiY2xjIiwiaGFuZGxlQ2FuY2VsbGVkIiwiZXZlbnRzIiwibWl0dCIsImNvbnN0cnVjdG9yIiwiaW5pdGlhbFByb3BzIiwiQXBwIiwid3JhcEFwcCIsIkNvbXBvbmVudCIsInN1YnNjcmlwdGlvbiIsImlzRmFsbGJhY2siLCJkb21haW5Mb2NhbGVzIiwiaXNQcmV2aWV3Iiwic2RjIiwic2JjIiwiaXNGaXJzdFBvcFN0YXRlRXZlbnQiLCJfa2V5Iiwib25Qb3BTdGF0ZSIsImUiLCJzdGF0ZSIsImNoYW5nZVN0YXRlIiwiZm9ybWF0V2l0aFZhbGlkYXRpb24iLCJnZXRVUkwiLCJfX05BIiwicmVsb2FkIiwiX19OIiwiZm9yY2VkU2Nyb2xsIiwia2V5Iiwic3RyaW5naWZ5IiwieCIsInNlbGYiLCJwYWdlWE9mZnNldCIsInkiLCJwYWdlWU9mZnNldCIsImdldEl0ZW0iLCJpc1NzciIsIl9icHMiLCJjaGFuZ2UiLCJzaGFsbG93IiwiX3NoYWxsb3ciLCJfaCIsImNvbXBvbmVudHMiLCJpbml0aWFsIiwicHJvcHMiLCJfX05fU1NHIiwiX19OX1NTUCIsInN0eWxlU2hlZXRzIiwiYXV0b0V4cG9ydER5bmFtaWMiLCJfX05FWFRfREFUQV9fIiwiYXV0b0V4cG9ydCIsIl9fTkVYVF9ST1VURVJfQkFTRVBBVEgiLCJzdWIiLCJfd3JhcEFwcCIsImlzTG9jYWxlRG9tYWluIiwiaXNSZWFkeSIsImdzc3AiLCJnaXAiLCJpc0V4cGVyaW1lbnRhbENvbXBpbGUiLCJhcHBHaXAiLCJnc3AiLCJzZWFyY2giLCJfX05FWFRfSTE4Tl9TVVBQT1JUIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwiaG9zdG5hbWUiLCJfaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSIsIl9zaG91bGRSZXNvbHZlSHJlZiIsImFkZEV2ZW50TGlzdGVuZXIiLCJzY3JvbGxSZXN0b3JhdGlvbiIsImJhY2siLCJmb3J3YXJkIiwicHVzaCIsInJlcGxhY2UiLCJfYmZsIiwic2tpcE5hdmlnYXRlIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQiLCJfYmZsX3MiLCJfYmZsX2QiLCJCbG9vbUZpbHRlciIsInN0YXRpY0ZpbHRlckRhdGEiLCJkeW5hbWljRmlsdGVyRGF0YSIsIl9fcm91dGVyRmlsdGVyU3RhdGljIiwiX19yb3V0ZXJGaWx0ZXJEeW5hbWljIiwiY29uc29sZSIsInJvdXRlckZpbHRlclNWYWx1ZSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX1NfRklMVEVSIiwicm91dGVyRmlsdGVyRFZhbHVlIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfRF9GSUxURVIiLCJudW1IYXNoZXMiLCJudW1JdGVtcyIsImVycm9yUmF0ZSIsImltcG9ydCIsIm1hdGNoZXNCZmxTdGF0aWMiLCJtYXRjaGVzQmZsRHluYW1pYyIsInBhdGhzVG9DaGVjayIsImN1ckFzIiwiYWxsb3dNYXRjaEN1cnJlbnQiLCJhc05vU2xhc2giLCJhc05vU2xhc2hMb2NhbGUiLCJjb250YWlucyIsIm5vcm1hbGl6ZWRBUyIsImN1ckFzUGFydHMiLCJzcGxpdCIsImkiLCJjdXJyZW50UGFydCIsImpvaW4iLCJpc0xvY2FsVVJMIiwiaXNRdWVyeVVwZGF0aW5nIiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJyZWFkeVN0YXRlQ2hhbmdlIiwicHJldkxvY2FsZSIsImxvY2FsZVBhdGhSZXN1bHQiLCJkZXRlY3RlZExvY2FsZSIsImRpZE5hdmlnYXRlIiwiZGV0ZWN0ZWREb21haW4iLCJkb21haW4iLCJhc05vQmFzZVBhdGgiLCJodHRwIiwiU1QiLCJwZXJmb3JtYW5jZSIsIm1hcmsiLCJzY3JvbGwiLCJyb3V0ZVByb3BzIiwiX2luRmxpZ2h0Um91dGUiLCJlbWl0IiwicmVtb3ZlTG9jYWxlIiwibG9jYWxlQ2hhbmdlIiwib25seUFIYXNoQ2hhbmdlIiwic2Nyb2xsVG9IYXNoIiwic2V0IiwiaXNFcnJvciIsInBhcnNlZCIsInVybElzTmV3IiwicGFyc2VkQXNQYXRobmFtZSIsIl9fYXBwUm91dGVyIiwiaXNNaWRkbGV3YXJlUmV3cml0ZSIsImlzTWlkZGxld2FyZU1hdGNoIiwicmV3cml0ZXNSZXN1bHQiLCJwIiwiZXh0ZXJuYWxEZXN0Iiwicm91dGVNYXRjaCIsInJvdXRlUmVnZXgiLCJzaG91bGRJbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZEFzIiwiaW50ZXJwb2xhdGVBcyIsIm1pc3NpbmdQYXJhbXMiLCJrZXlzIiwiZ3JvdXBzIiwiZmlsdGVyIiwicGFyYW0iLCJvcHRpb25hbCIsIndhcm4iLCJvbWl0IiwiaXNFcnJvclJvdXRlIiwicm91dGVJbmZvIiwiZ2V0Um91dGVJbmZvIiwiY2xlYW5lZFBhcnNlZFBhdGhuYW1lIiwiZm9yRWFjaCIsInByZWZpeGVkQXMiLCJyZXdyaXRlQXMiLCJsb2NhbGVSZXN1bHQiLCJjdXJSb3V0ZU1hdGNoIiwiY29tcG9uZW50IiwidW5zdGFibGVfc2NyaXB0TG9hZGVyIiwic2NyaXB0cyIsImNvbmNhdCIsInNjcmlwdCIsImhhbmRsZUNsaWVudFNjcmlwdExvYWQiLCJwYWdlUHJvcHMiLCJfX05fUkVESVJFQ1QiLCJfX05fUkVESVJFQ1RfQkFTRV9QQVRIIiwicGFyc2VkSHJlZiIsIl9fTl9QUkVWSUVXIiwibm90Rm91bmRSb3V0ZSIsImZldGNoQ29tcG9uZW50IiwiXyIsImlzTm90Rm91bmQiLCJzdGF0dXNDb2RlIiwiaXNWYWxpZFNoYWxsb3dSb3V0ZSIsInNob3VsZFNjcm9sbCIsInJlc2V0U2Nyb2xsIiwidXBjb21pbmdTY3JvbGxTdGF0ZSIsInVwY29taW5nUm91dGVyU3RhdGUiLCJjYW5Ta2lwVXBkYXRpbmciLCJjb21wYXJlUm91dGVyU3RhdGVzIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJsYW5nIiwiaGFzaFJlZ2V4IiwiaGFuZGxlUm91dGVJbmZvRXJyb3IiLCJsb2FkRXJyb3JGYWlsIiwiaXNBc3NldEVycm9yIiwiZ2V0SW5pdGlhbFByb3BzIiwiZ2lwRXJyIiwicm91dGVJbmZvRXJyIiwicmVxdWVzdGVkUm91dGUiLCJleGlzdGluZ0luZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJmZXRjaE5leHREYXRhUGFyYW1zIiwiZ2V0RGF0YUhyZWYiLCJza2lwSW50ZXJwb2xhdGlvbiIsInJlc29sdmVkUm91dGUiLCJpc0FQSVJvdXRlIiwicmVzIiwibW9kIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwid2FzQmFpbGVkUHJlZmV0Y2giLCJzaG91bGRGZXRjaERhdGEiLCJfZ2V0RGF0YSIsImZldGNoZWQiLCJnZXRQcm9wZXJFcnJvciIsImJlZm9yZVBvcFN0YXRlIiwiY2IiLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwibmV3VXJsTm9IYXNoIiwibmV3SGFzaCIsImRpc2FibGVTbW9vdGhTY3JvbGxEdXJpbmdSb3V0ZVRyYW5zaXRpb24iLCJzY3JvbGxUbyIsInJhd0hhc2giLCJkZWNvZGVVUklDb21wb25lbnQiLCJpZEVsIiwiZ2V0RWxlbWVudEJ5SWQiLCJzY3JvbGxJbnRvVmlldyIsIm5hbWVFbCIsImdldEVsZW1lbnRzQnlOYW1lIiwib25seUhhc2hDaGFuZ2UiLCJwcmVmZXRjaCIsImlzQm90IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidXJsUGF0aG5hbWUiLCJvcmlnaW5hbFBhdGhuYW1lIiwiX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0giLCJfaXNTc2ciLCJpc1NzZyIsInByaW9yaXR5IiwiX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFIiwiY29tcG9uZW50UmVzdWx0IiwibG9hZFBhZ2UiLCJmbiIsImN0eCIsIkFwcFRyZWUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/../node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});